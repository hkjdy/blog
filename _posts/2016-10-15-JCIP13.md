---
date: 2016/10/15 星期六  14:48:26+0800
layout: post
title: JCIP-13 显式锁
thread: 164
categories: 读书笔记
tags:  JCIP
---


在Java 5.0之前，在调用对共享对象的访问时可以使用的机制只有synchonized和volatile。Java 5.0 增加了一种新的机制：ReentrantLock。与之前提到的机制相反，**ReentrantLock并不是一种替代内置加锁的方法，而是当内置加锁机制不适用时，作为一种可选择的高级功能。**

## 1. Lock与ReentrantLock

与内置加锁机制不同的是，Lock提供了一种 **无条件的**、**可轮询的**、**定时的**以及**可中断的**锁获取操作，所有加锁和解锁的方法都是显式的。在Lock的实现中必须提供与内部锁相同的 **内存可见性** 语义，但在加锁语义、调度算法、顺序保证以及性能等方面可以有所不同。

ReentrantLock实现了Lock接口，并提供了与synchronized相同的互斥和内存可见性。ReentrantLock支持在Lock接口中定义的所有获取锁模式，并且与synchronized相比，它还为处理锁的不可用性问题提供了更高的灵活性。

为什么要创建一个与内置锁如此相似的新加锁机制？在某些情况下内置锁存在一些局限性，例如，无法中断一个正在等待获取锁的线程，或者无法在请求获取一个锁时无限地等待下去。

### 1.1 轮询锁与定时锁

在内置锁中恢复死锁程序的唯一方法是重新启动程序，可轮询的与可定时的锁提供了另一种选择：避免死锁的发生。

如果不能获得所有需要的锁，那么可以使用可轮询或可定时的锁获取方式，从而使你重新获得控制权，它会释放已经获得的锁，然后重新尝试获取所有锁。

在实现具有时间限制的操作时，定时锁同样非常有用，当在带有时间限制的操作中调用了一个阻塞方法时，它能根据剩余时间来提供一个时限，如果操作不能在指定的时间内给出结果，那么就会使程序提前结束。当使用内置锁时，在开始请求后，这个操作将无法取消，因此内置锁很难实现带有时间限制的操作。

### 1.2 可中断的锁获取操作

可中断的锁获取操作能在可取消的操作中使用加锁。lockInterruptibly 方法能够在获得锁的同时保持对中断的响应，并且由于它包含在Lock中，因此无须创建其他类型的不可中断阻塞机制。

可中断的锁获取操作的标准结构比普通的锁获取操作略微复杂一些。见程序清单：

```java
//程序清单：可中断的锁获取操作

public class InterruptibleLocking {
    private Lock lock = new ReentrantLock();

    public boolean sendOnSharedLine(String message)
            throws InterruptedException {
        lock.lockInterruptibly();
        try {
            return cancellableSendOnSharedLine(message);
        } finally {
            lock.unlock();
        }
    }

    private boolean cancellableSendOnSharedLine(String message) throws InterruptedException {
        /* send something */
        return true;
    }

}
```


## 2. 公平性

在ReentrantLock的构造函数中提供了两种公平性选择：创建一个非公平的锁（默认）或者一个公平的锁。在公平的锁上，线程将按照它们发出请求的顺序来获得锁，但在非公平的锁上，则允许“插队”。

我们为什么不希望所有的锁都是公平的？ 当执行加锁操作时，公平性将由于在挂起线程和恢复线程时存在的开销而极大地降低性能。

在激烈竞争的情况下，非公平锁的性能高于公平锁的性能的一个原因是：在恢复一个被挂起的线程与该线程真正开始运行之间存在着严重的延迟。

当持有锁的时间相对较长，或者请求锁的平均时间间隔较长，那么应该使用公平锁。在这些情况下，“插队”带来的吞吐量提升则可能不会出现。

与默认的ReentrantLock一样，内置加锁并不会提供确定的公平性保证，但在大多数情况下，在锁实现上实现 **统计上的公平性保证**[^2] 已经足够了。Java语言规范并没有要求JVM以公平的方式来实现内置锁，而在各种JVM中也没有这样做。ReentrantLock并没有进一步降低锁的公平性，而只是使一些已经存在的内容更明显。

## 3. 在synchronized和ReentrantLock之间进行选择

ReentrantLock在加锁和内存上提供的语义与内置锁相同，此外它还提供了一些其他功能，包括定时的锁等待、可中断的锁等待、公平性，以及实现非块结构的加锁。

ReentrantLock在性能上似乎优于内置锁，但是，与显式锁相比，内置锁仍然具有很大优势。内置锁为许多开发人员所熟悉，并且简洁紧凑，而且在许多现有的程序中都已经使用了内置锁。ReentrantLock的危险性比同步机制要高，如果忘记在finally块中调用unlock，那么虽然代码表现上能正常运行，但实际上已经埋下了一颗定时炸弹，并很可能伤及其他代码。仅当内置锁不能满足需求时，才可以考虑使用ReentrantLock。

在一些内置锁无法满足需求的情况下，ReentrantLock可以做为一种高级工具。当需要一些高级功能时才应该使用ReentrantLock。这些功能包括：可定时的、可轮询的与可中断的锁获取操作、公平队列、以及非块结构的锁。否则，还是应该优先使用synchronized。


## 4. 读-写锁

ReentrantLock实现了一种标准的 **互斥锁**[^3]。互斥通常是一种过于强硬的加锁规则，因此也就不必要地限制了并发性。互斥是种保守的加锁策略，虽然可以避免 **写-写** 冲突和 **写-读** 冲突，但同样也避免了 **读-读** 冲突。如果某个数据结构的大部分操作都是读操作，此时允许多个执行读操作的线程同时访问数据结构，那么将提升程序的性能。在这种情况下就可以使用**读-写**锁[^4]。接口如下：

```java
//程序清单：ReadWriteLock接口

public interface ReadWriteLock {
	Lock readLock();
	Lock writeLock();
}
```
ReadWriteLock 中暴露了两个Lock对象，其中一个用于读操作，而另一个用于写操作。要读由ReadWriteLock保护的数据，必须首先获得读取锁，当需要修改ReadWriteLock 保护的数据时，必须首先获得写入锁。


## 总结

与内置锁相比，显式的Lock提供了一些扩展功能，在处理锁的不可用性方面有着更高的灵活性，并且对队列行有着更好的控制。但ReentrantLock不能完全替代synchronized，只有在synchronized无法满足需求时，才应用使用它。

读-写锁允许多个读线程并发地访问被保护的对象，当访问以读取操作为主的数据结构时，它能提高程序的可伸缩性。

[^1]: **内存可见性** 内存可见性。

[^2]: **统计上的公平性保证** 确保被阻塞的线程能最终获得锁。

[^3]: **互斥锁** 每次最多只有一个线程能持有ReentrantLock。

[^4]: **读-写锁** 一个资源可以被多个读操作访问，或者被一个写操作访问，但两者不能同时进行。
