---
date: 2016/9/10 星期六  16:51:52+0800
layout: post
title: 【读书笔记】Java并发编程实战
thread: 164
categories: 读书笔记
tags:  读书笔记
---

#### Java并发编程实战

##### [豆瓣地址](https://book.douban.com/subject/10484692/)

#### 内容简介
本书深入浅出地介绍了Java线程和并发，是一本完美的Java并发参考手册。书中从并发性和线程安全性的基本概念出发，介绍了如何使用类库提供的基本并发构建块，用于避免并发危险、构造线程安全的类及验证线程安全的规则，如何将小的线程安全类组合成更大的线程安全类，如何利用线程来提高并发应用程序的吞吐量，如何识别可并行执行的任务，如何时提高单线程子系统的响应性，如何确保并发程序执行预期任务，如何提高并发代码的性能和可伸缩性等内容，最后介绍了一些高级主题，如显式锁、原子变量、非阻塞算法以及如何开发自定义的同步工具类。

#### 一、简介

- **为什么要编写并发程序？**

线程是Java语言中不可或缺的重要功能，它们能使复杂的异步代码变得更简单，从而极大地简化了复杂系统的开发。此外，还能充分发挥多处理器系统的强大计算能力。

- **串行编程模型的优势**

直观性和简单性，因为它模仿了人类的工作方式：每次只做一件事情，做完之后再做另一件。

- **线程的优势**

线程能发挥多处理器的强大能力。如果使用得当，线程可以有效地降低程序的开发和维护成本，同时提升复杂应用程序的性能。此外，线程还可以降低代码的复杂度，使代码更容易编写、阅读和维护。
在GUI应用程序中，线程可以提高用户界面的响应灵敏度，而在服务器应用程序中，可以提升资源利用率以及系统吞吐率。线程还可以简化JVM的实现，垃圾收集器通常在一个或多个专门的线程中运行。

- **线程带来的风险**

安全性问题[^1]、活跃性问题[^2]、性能问题。

#### 二、线程安全性

要编写线程安全的代码，其核心在于要对状态[^3]访问操作进行管理，特别是对共享的[^4]（Shared）和可变的[^5]（Mutable）状态的访问。

当多个线程访问某个变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。Java中的主要同步机制是关键字synchronized，它提供了一种独占的加锁方式，但“同步”这个术语还包括volatile类型的变量，显式锁以及原子变量。

如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题。

- 不在线程之间共享该状态变量。
- 将状态访问变量修改为不可变的变量。
- 在访问状态变量时使用同步。

**什么是线程安全性**

当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协调，这个类都能表现出正确的行为，那么就称这个类是线程安全的。


**无状态对象一定是线程安全的**

```
@ThreadSafe
public class StatelessFactorizer extends GenericServlet implements Servlet {

    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        encodeIntoResponse(resp, factors);
    }

    void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) {
    }

    BigInteger extractFromRequest(ServletRequest req) {
        return new BigInteger("7");
    }

    BigInteger[] factor(BigInteger i) {
        // Doesn't really factor
        return new BigInteger[] { i };
    }
}
```

StatelessFactorizer是无状态的：它既不包含任何域，也不包含任何对其他类中域的引用。

**竞态条件**[^6] 类型

- 先检查后执行
- 延迟初始化
- 复合操作

**用锁来保护状态**

由于锁能使用其保护的代码路径以串行形式来访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问。只要始终遵循这些协议，就能确保状态的一致性。

**活跃性与性能**

通常，在简单性与性能之间存在着相互制约因素。当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性。


#### 三、对象的共享


[^1]: **安全性** 的含义是：永远不发生糟糕的事情。

[^2]: **活跃性** 的含义是：某件正确的事情最终会发生。

[^3]: **对象的状态** 是指存储在状态变量中的数据。

[^4]: **共享** 意味着变量可以由多个线程同时访问。

[^5]: **可变** 意味着变量的值在期生命周期内可以发生变化。

[^6]: **竞态条件** 由于不恰当的执行时序而出现不正确的结果。


