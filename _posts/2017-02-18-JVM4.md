---
date: 2017/2/18 星期六  18:19:00+0800
layout: post
title: 深入理解Java虚拟机(4)-虚拟机性能监控与故障处理工具
thread: 164
categories: 读书笔记
tags:  深入理解Java虚拟机
---

本文将介绍随JDK发布的6个命令行工具与两个可视化的故障处理工具的使用方法。

# 一.概述

给一个系统定位问题的时候，知识、经验是关键基础，数据是依据，工具是运用知识处理数据的手段。这里说的数据包括：运行日志、异常堆栈、GC日志、线程快照、堆转储快照等。经常使用适当的虚拟机监控和分析的工具可以加快我们分析数据、定位解决问题的速度。

# 二.JDK命令行工具

JDK的命令行工具位于JDK的bin目录，本文将介绍这些工具的其中一部分，主要包括用于监视虚拟机和故障处理的工具。

![JVM](/assets/jvm/4/01.png)

## 1.jsp:虚拟机进程状况工具

**jps** 可以列出正在运行的虚拟机进程，并显示虚拟机主类（Main Class,main()函数所在的类）名称以及这些进程的本地唯一ID(Local Virtual Machine Identifier, LVMID)。虽然功能比较单一，但它是使用频率最高的JDK命令行工具。

### jps命令格式

`jps [options] [hostid]`

### jps执行样例

```
[root@hkjdy ~]# jps -l
19720 sun.tools.jps.Jps
18667 org.apache.catalina.startup.Bootstrap
```
jps可以通过RMI协议查询开启了RMI服务的远程虚拟机进程状态，hostid为RMI注册表中注册的主机名。jps的其他常用选项如下：

- `-q`：只输出LVMID，省略主类的名称。
- `-m`：输出虚拟机程序启动时传递给主类main()函数的参数。
- `-l`：输出主类的全名，如果进程执行的是Jar包，输入Jar路径。
- `-v`：输出虚拟机进程启动时JVM参数。

## 2.jstat:虚拟机统计信息监视工具

**jstat**(JVM Statistics Monitoring Tool)是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。

### jstat命令格式为：

```jstat [option vmid [interval [s|ms] [count]]]```

对于命令格式中的VMID与LVMID需要说明一下：如果是本地虚拟机进程，VMID与LVMID是一致的，如果是远程虚拟机进行，那VMID的格式应当是：

*[protocol:][//]lvmid[@hostname[:port]/servername]*

参数interval和count代表查询间隔和次数，如果省略这两个参数，说明只查询一次。假设需要每250毫秒查询一次进程29539垃圾收集情况，一共查询20次，那命令应当是：

```jstat -gc 29539 250 20```

选择option代表着用户希望查询的虚拟机信息，主要分为3类：类装载、垃圾收集、运行期编译情况。具体选项及作用如下：

- `-class`：监视类装载、卸载数量、总空间以及类装载所耗费的时间。
- `-gc`：监视Java堆状况，包括Eden区、两个survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息。
- `-gccapacity`：监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间。
- `-gcutil`：监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比。
- `-gccause`：与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因。
- `-gcnew`：监视新生代GC状况。
- `-gcnewcapacity`：监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间。
- `-gcold`：监视老年代GC状况。
- `-gcoldcapacity`：监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间。
- `-gcpermcapacity`：输出永久代使用到的最大、最小空间。
- `-compiler`：输出JIT编译器编译过的方法、耗时等信息。
- `-printcompilation`：输出已被JIT编译的方法。

### jstat执行样例

```
[root@hkjdy dengyi]# jstat -gcutil 29539
  S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT   
 11.46   0.00   7.48  33.25  98.50 141690  602.403  2588  266.960  869.362
```

查询结果表明：这台服务器的新生代Eden区(E表示Eden)使用了7.48%的空间，两个Survivor区(S0,S1表示Surivivor0,Survivor1)分别使用了11.46%和0%的空间，老年代(O表示Old)和永久代(P表示Permanent)则分别使用了33.25%和98.50%的空间。程序运行以来共发生Minor GC(YGC表示Young GC)141690次，总耗时(YGCT表示Young GC Time)602.403秒，发生Full GC(FGC表示Full GC)2588次，Full GC总耗时(FGCT表示Full GC Time)为266.960秒，所有GC总耗时(GCT表示GC Time)为869.362秒。

## 3.jinfo:Java配置信息工具

**jinfo** (Configuration Info for Java) 的作用是实时地查看和调整虚拟机各项参数。使用jps命令的-v参数可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显示指定的参数的系统默认值，除了去找资料外，就只能用jinfo的-flag选项进行查询了（如果只限于JDK 1.6以上版本的话，使用java-XX:+PrintFlagsFinal查看参数默认值也是一个很好的选择），jinfo还可以使用-sysprops选项把虚拟机进程的System.getProperties()的内容打印出来。

### 命令格式

```jinfo [option] pid```

### 执行样例：查询CMSInitiatingOccupancyFraction参数值

```
[root@hkjdy dengyi]# jinfo -flag CMSInitiatingOccupancyFraction 29539
-XX:CMSInitiatingOccupancyFraction=-1
```

## 4.jmap:Java内存映像工具

**jmap** (Memory Map for Java)命令用于生成堆转储快照(一般称为heapdump或dump文件)。如果不使用jmap命令，要想获取Java堆转储快照，还有一些比较暴力的手段：譬如使用`-XX:+HeapDumpOnOutOfMemoryError`参数，可以让虚拟机在OOM异常出现之后自动生成dump文件，通过 `-XX:+HeapDumpOnCtrlBreak` 参数则可以使用`Ctrl+Break`键让虚拟机生成dump文件，又或者在Linux系统下通过`kill -3`命令发送进程退出信号，也能得到dump文件。

### jmap命令格式

```jmap [option] vmid```

### option选择的合法值

- `-dump`：生成Java堆转储快照。格式为`-dump:[live,] format=b, file=<filename>`，其中live子参数说明是否只dump出存活的对象。
- `-finalizerinfo`：显示在F-Queue中等待Finalizer线程执行finalizer方法的对象。只在Linux/Solaris平台下有效。
- `-heap`：显录Java堆详细信息，如使用哪种回收器、参数配置、分代状况等。只在Linux/Solaris平台有效。
- `-histo`：显示堆中对象统计信息，包括类、实例数量、合计容量。
- `-permstat`：以ClassLoader为统计口径显示永久代内存状态。只在Linux/Solaris平台下有效。
- `-F`：当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照。只在Linux/Solaris平台下有效。

### 使用dump生成dump文件

```
[root@hkjdy dengyi]# jmap -dump:format=b,file=eclipse.bin 29539
Dumping heap to /home/dengyi/eclipse.bin ...
Heap dump file created
```

## 5.jhat:虚拟机堆转储快照分析工具

Sun JDK提供 **jhat** (JVM Heap Analysis Tool)命令与jmap搭配使用，来分析jmap生成的堆转储快照。jhat内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，可以在浏览器中查看。

### 使用jhat分析dump文件

```
jhat eclipse.bin
```

屏幕显示 **Server is ready**的提示后，在浏览器中输入`http://127.0.0.1:7000/`就可以看到分析结果。

分析结果默认是以包为单位进行分组显示，分析内存泄漏问题主要会使用到其中的 **Heap Histogram**(与jmap -histo功能一样)与OQL页签的功能，前者可以找到内存中总容量最大的对象，后者是标准的对象查询语言，使用类似SQL的语法对内存中的对象进行查询统计。

## 6.jstack:Java堆栈跟踪工具

**jstack** (Stack Trace for Java)命令用于生成虚拟机当前时刻的线程快照(一般称为threaddump或者javacore文件)。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者等待着什么资源。


### jstack命令格式

```jstack [option] vmid```

### option选项的合法值与具体含义:

- `-F`：当正常输出的请求不被响应时，强制输出线程堆栈。
- `-l`：除堆栈外，显示关于锁的附加信息。
- `-m`：如果调用到本地方法的话，可以显示C/C++的堆栈。

### 使用jstack查看线程堆栈(部分结果)

```
jstack -l 29539
Full thread dump OpenJDK 64-Bit Server VM (24.91-b01 mixed mode):

"Attach Listener" daemon prio=10 tid=0x00007fdf4c098000 nid=0x2886 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
	- None

"NioProcessor-6" prio=10 tid=0x00007fdef001a000 nid=0x6c95 runnable [0x00007fde763bf000]
   java.lang.Thread.State: RUNNABLE
	at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)
	at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:269)
	at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:79)
	at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:87)
	- locked <0x0000000706ec8428> (a sun.nio.ch.Util$2)
	- locked <0x0000000706ec8418> (a java.util.Collections$UnmodifiableSet)
	- locked <0x0000000706ec8300> (a sun.nio.ch.EPollSelectorImpl)
	at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:98)
	at org.apache.mina.transport.socket.nio.NioProcessor.select(NioProcessor.java:72)
	at org.apache.mina.core.polling.AbstractPollingIoProcessor$Processor.run(AbstractPollingIoProcessor.java:1093)
	at org.apache.mina.util.NamePreservingRunnable.run(NamePreservingRunnable.java:64)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
	at java.lang.Thread.run(Thread.java:745)

   Locked ownable synchronizers:
	- <0x000000070a05dfa8> (a java.util.concurrent.ThreadPoolExecutor$Worker)
```

## 7.HSDIS:JIT生成代码反汇编

分析程序如何执行，通过软件调试工具来断点调试是最常见的手段，但是这样的调试方式在Java虚拟机中会遇到很大困难，因为大量执行代码是通过JIT编译器动态生成到CodeBuffer中的，没有简单的手段来处理这种混合模式的调试。基于这种背景，本文的主角——HSDIS插件就正式登场了。

HSDIS是一个Sun官方推荐的HotSpot虚拟机JIT编译代码的反汇编插件，它包含在HotSpot虚拟机的源码之中，但没有提供编译后的程序。它的作用是让HotSpot的`-XX:+PrintAssembly`指令调用它来把动态生成的本地代码还原为汇编代码输出，同时还生成大量非非常有价值的注释，这样我们可以通过输出的代码来分析问题。

关于HSDIS的用法可参考[http://www.infoq.com/cn/articles/zzm-java-hsdis-jvm](http://www.infoq.com/cn/articles/zzm-java-hsdis-jvm)

# 三.JDK的可视化工具

JDK中除了提供大量的命令行工具外，还有两个功能强大的可视化工具：JSconsole和VisualVM。下面将介绍这两个工具。

## 1.JConsole:Java监视与管理控制台

### 1)启动JConsole

通过`JDK/bin`目录下的**jconsole.exe** 启动后，将自动搜索出本机运行的所有虚拟机进程。如下图：

![JVM](/assets/jvm/4/02.png)

双击其中一个进程即可开始监控。主界面共包括 **概述**、**内存**、**线程**、**类**、**VM概要**、**MBean**6个页签，如下图：

![JVM](/assets/jvm/4/03.png)

**概述** 页签显示的是整个虚拟机主要运行数据的概览，其中包括**堆内存使用量**、**线程**、**类**、**CPU占用率**四种信息的曲线图，这些曲线图是后面 **内存**、**线程**、**类**页签的信息汇总。

### 2)内存监控

**内存** 页签相当于可视化的jstat命令，用于监视受收集器管理的虚拟机内存（Java堆和永久代）的变化趋势。

### 3)线程监控

**线程** 页签的功能相当于可视化的jstack命令，遇到线程停顿时可以使用这个页签进行监控分析。

## 2.VisualVM:多合一故障处理工具

VisualVM是到目前为止随JDK发布的功能最强大的运行监视和故障处理程序。VisualVM除了运行监视、故障处理外，还提供了很多其他方面的功能，如性能分析。而且VisualVM还有一个很大的优点：不需要被监视的程序基于特殊Agent运行，因此它对程序程序的实际性能的影响很小，使得它可以直接应用在生产环境中。

### 1) VisualVM兼容范围与插件安装

VisualVM基于NetBeans平台开发，因此它一开始就具备了插件扩展功能的特性，通过插件扩展支持，VisualVM可以做到：

- 显示虚拟机进行以及进程的配置、环境信息(jps、jinfo)。
- 监视应用程序的CPU、GC、堆、方法区以及线程的信息(jstat、jstack)。
- dump以及分析堆转储快照(jmap、jhat)。
- 方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法。
- 离线程序快照：收集程序的运行时配置、线程dump、内存dump等信息建立一个快照，可以将快照发送开发者处进行BUG反馈。

首次启动`jvisualvm.exe`后，VisualVM还没有装任何扩展插件。虽然基本的监视、线程面板的功能主程序都以默认插件的形式提供了，但是不给VisualVM装任何扩展插件，就相当于放弃了它最精华的功能。

安装插件或以选择手工安装或是在线安装，这里选择在线安装。点击`工具-插件` 在 **可用插件** 标签页下选择需要安装的插件，点击 `安装` 按钮，跟着提示操作即可完成安装。

![JVM](/assets/jvm/4/04.png)

安装完插件，选择一个需要监视的程序就进入程序的主界面了。如下图：

![JVM](/assets/jvm/4/05.png)

### 2) 生成、浏览堆转储快照

在VisualVM中生成dump文件有两种方式：

1. 在 **应用程序** 窗口中右键单击应用程序节点，然后选择 **堆dump**。
2. 在 **应用程序** 窗口中双击应用程序节点以打开应用程序标签，然后在 **监视** 标签中单击 **堆dump**。

生成了dump文件后，应用程序标签将在该堆的应用程序下增加一个以[heapdump]开头的子节点，并且在主页签中打开了该转储快照。如果需要把dump文件保存或发送出去，要在heapdump节点上右键选择 **另存为** 菜单，否则当VisualVM关闭时，生成的dump文件会被当做临时文件删除掉。要打开一个已经存在的dump文件，通过文件菜单中的 **装入** 功能，选择硬盘上的dump文件即可。

### 3) 分析程序性能

在Profiler页签中，VisualVM提供了程序运行期间方法级的CPU执行时间分析以及内存分析，做Profiling分析肯定会对程序运行性能有比较大的影响，所以一般不在生产环境中使用这项功能。

要开始分析，先选择 **CPU** 和 **内存** 按钮中的一个，然后切换到应用程序中对程序进行操作，VisualVM会记录到这段时间中应用程序执行过的方法。如果是CPU分析，将会统计每个方法的执行次数、执行耗时；如果是内存分析，则会统计每个方法关联的对象数以及这些对象所占的空间。分析结束后，点击 **停止** 按钮结束监控过程。

### 4) BTrace动态日志跟踪

**BTrace** 是一个很**有趣**的VisualVM插件，本身也是可以独立运行的程序。它的作用是在不停止目标程序运行的前提下，通过HotSpot虚拟机的HotSwap技术动态加入原本不存在的调试代码。这项功能对实际生产中的程序很有意义：经常遇到程序出现问题，但排查错误的一些必要信息，譬如方法参数、返回值等，在开发时并没有打印到日志之中，以至于不得不停掉服务，通过调试增量来加入日志代码以解决问题。

在VisualVM中安装了BTrace插件后，在应用程序面板中右键点击要调试的程序，会出现 **Trace application...** 菜单，点击将进入BTrace面板。这个面板里面看起来就像一个简单的Java程序开发环境，里面还有一小段代码，如下图所示：

![JVM](/assets/jvm/4/06.png)

这里准备了一段很简单的Java代码来演示BTrace的功能。

```java
package cn.hkjdy.jvm;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class BTraceTest {
	public int add(int a, int b) {
		return a+b;
	}

	public static void main(String[] args) throws IOException {
		BTraceTest test = new BTraceTest();
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
		reader.readLine();
		System.out.println(test.add(1, 2));
	}
}
```

程序运行后，在VisualVM中打开该程序的监视，在BTrace页签填充TracingScript内容，输入的调试代码如下：

```java
import com.sun.btrace.annotations.*;
import static com.sun.btrace.BTraceUtils.*;

@BTrace
public class TracingScript {
	@OnMethod(
        clazz="cn.hkjdy.jvm.BTraceTest",
        method="add",
        location=@Location(Kind.RETURN)
    )
	public static void func(@Self cn.hkjdy.jvm.BTraceTest instance,int a,int b,@Return int result){
		println("调用堆栈：");
		jstack();
		println(strcat("方法参数A：",str(a)));
		println(strcat("方法参数B：",str(b)));
		println(strcat("方法结果：",str(result)));
	}
}
```

点击 **Start** 按钮后稍等片刻，编译完成后，可见Output面板中运行结果：

```
** Compiling the BTrace script ...
*** Compiled
** Instrumenting 1 classes ...
*** Done
** BTrace up&running

*** Done
** BTrace up&running
```

回到Eclipse，在控制台回车，让程序继续执行，完成后回到VisualVM会看到控制台输出如下信息：

```
调用堆栈：
cn.hkjdy.jvm.BTraceTest.add(BTraceTest.java:9)
cn.hkjdy.jvm.BTraceTest.main(Unknown Source)
方法参数A：1
方法参数B：2
方法结果：3
** BTrace has stopped
** BTrace has stopped
```

BTrace的用法还有许多，打印调用堆栈、参数、返回值只是最基本的应用，在它的网站上有使用BTrace进行性能监视、定位连接泄漏和内存泄漏、解决多线程竞争问题等例子。

# 总结

本文介绍了随JDK发布的6个命令行工具及两个可视化的故障处理工具，灵活使用这些工具可以给问题处理带来很大的便利。