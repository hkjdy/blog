---
date: 2017/2/17 星期五  12:26:35+0800
layout: post
title: 深入理解Java虚拟机(3)-垃圾收集器与内存分配策略
thread: 164
categories: 读书笔记
tags:  深入理解Java虚拟机
---

本文分析了垃圾收集的算法和JDK 1.7中提供的几款垃圾收集器的特点及运作原理。通过代码实例验证了Java虚拟机中自动内存分配及回收的主要规则。

# 一、概述

目前内存的动态分配与内存回收技术已经相当成熟，那为什么我们还要去了解GC和内存分配呢？原因是：当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些技术实施必要的监控和调节。

Java内存运行时区域中的程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。

而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存，本文后续讨论中的 **内存** 分配与回收也仅指这一部分内存。

# 二、对象已死吗

在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还 **存活** 着，哪些已经 **死去** (即不可能再被任何途径使用的对象)。

## 1.引用计数算法

**引用计数算法** 是指给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。这种方法的实现简单，判定效率也高，在大部分情况下它都是一个不错的算法。但是，至少主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。

## 2.可达性分析算法

在主流的商用程序语言的主流实现中，都是通过可达性分析来判定对象是否存活的。这个算法的基本思路就是：通过一系列的称为 **GC Roots** 的对象做为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，将会被判定为是 **可回收的对象**。

在Java语言中，可作为GC Roots的对象包括下面几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI(即一般说法的Native方法)引用的对象。

## 3.再谈引用

在JDK 1.2之前，Java中一个对象只有被引用和没有被引用两种状态。

在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用和虚引用4种，这4种引用强度依次逐渐减弱。

**强引用** 就是指在程序代码之中普遍存在的，只要引用还存在，垃圾收集器永远不会回收掉被引用的对象。

**软引用** 是用来描述一些还有用，但并非必需的对象。对于软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。

**弱引用** 也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。

**虚引用** 也称为 **幽灵引用** 或者 **幻影引用**，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时刻收到一个系统通知。

## 4.生存还是死亡

即使在 **可达性分析算法中** 不可达的对象，也并非是 **非死不可的**，这时候它们暂时处于 **缓刑** 阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为 **没有必要执行**。

如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做 F-Queue的队列之中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可。那在第二次标记时它将被移除 **即将回收** 的集合；如果对象这时候还没有逃脱，那基本上就真的被回收了。

## 5.回收方法区

Java虚拟机规范中说过可以不要求虚拟机在方法区（或者HotSpot虚拟机中的永久代）实现垃圾收集，在方法区中进行垃圾收集的 **性价比** 一般比较低。

永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。

如果没有任何对象引用常量池中的常量，在发生内存回收的时候，如果必要的话常量会被系统清理出常量池。

类需要同时满足下面3个条件才能算是 **无用的类**：

1. 该类所有的实例都已经被回收。
2. 加载该类的ClassLoader已经被回收。
3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

虚拟机 **可以** 对满足上述3个条件的无用类进行回收。

# 三、垃圾收集算法

这里介绍几种垃圾收集算法的思想及其发展过程，不针对特定平台的虚拟机。

## 1.标记-清除算法

最基础的收集算法是 **标记-清除** 算法，分为 **标记** 和 **清除** 两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

它的主要不足有两个：一是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片。空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

## 2.复制算法

为了解决效率问题，出现了一种称为 **复制** 的收集算法。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使用得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单、运行高效。只是这种算法的代价是将可用内存缩小为了原来的一半。

现在的商业虚拟机都采用这种收集算法来回收新生代。虚拟机不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和刚才用过的Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1。当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。

## 3.标记-整理算法

复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。

根据老年代的特点，有人提出了另外一种 **标记-整理** 算法，标记过程仍然与 **标记-清除** 算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉另一端边界以外的内存。

## 4.分代收集算法

当前商业虚拟机的垃圾收集都采用 **分代收集**算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用 **标记-清理** 或者 **标记-整理** 算法来进行回收。

# 四、HotSpot算法的实现

前面从理论上介绍了对象存活判定算法和垃圾收集算法，而在HotSpot虚拟机上实现这些算法时，必须对算法的执行效率有严格的考量，才能保证虚拟机高效运行。

## 1.枚举根节点

以可达性分析中从GC Roots节点找引用链这个操作为例，作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。

另外可达性分析对执行时间的敏感还体现在 **GC停顿** 上，因为这项分析工作必须在一个能确保一致性的快照中进行。

由于目前的主流Java虚拟机使用的都是准确式GC，所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC扫描时就可以直接得知这些信息了。

## 2.安全点

在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。

实际上，HotSpot只是在 **特定的位置** 记录了这些信息，这些位置称为 **安全点**，即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。

对于安全点，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都跑到最近的安全点上再停顿下来。这里有两种方案可供选择：

1) 抢先式中断：不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。

2) 主动式中断：它的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。

## 3.安全区域

安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的安全点。但是程序 **不执行的时候**（例如线程处于Sleep或Blocked状态）呢？对于这种情况，就需要安全区域来解决。

安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。我们也可以把安全区域看到是被扩展了的安全点。

在线程执行到安全区域中的代码时，首先标识自己已经进入了安全区域，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为 **安全区域** 状态的线程了。在线程要离开 **安全区域** 时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则必须等待直到收到可以安全离开 **安全区域** 的信息为止。

# 五、垃圾收集器

如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了HotSpot虚拟机7种作用于不同分代的收集器。如果两个收集器之间存在连线，就说明它们可以搭配使用。

![JVM](/assets/jvm/3/01.png)

## 1.Serial收集器

Serial收集器是最基本、发展历史最悠久的收集器。这个收集器是一个**单线程的收集器**。它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。这样会给用户带来不良的体验，因为它会在用户不可见的情况下把用户正常工作的线程全部停掉。

Serial收集器也不是一无事处，它依然是虚拟机运行在Client模式下的默认新生代收集器。它也有着优于其他收集器的地方

- 简单而高效（与其他收集器的单线程比）
- 对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程效率。
- 在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒以内，只要不是频繁发生，这点停顿是可以接受的。

所以，Serial收集器对运行在Client模式下的虚拟机来说是一个很好的选择。

## 2.ParNew收集器

ParNew收集器其实就是Serial收集器的多线程版本。ParNew收集器除了多线程收集之外，其他与Serial收集器相比没有太多创新之处。但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。

ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，随着可以使用CPU数量的增加，它对于GC时系统资源的有效利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同。

## 3.Parallel Scavenge收集器

Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行[^1]的多线程收集器……看上去和ParNew都一样，那它有什么特别之处呢？

Parallel Scavenge收集器的特点是它的关注点与其它收集器的 **尽量缩短用户线程的停顿时间** 不同，Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量[^3]。

停顿时间越短越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。

### 控制参数

`-XX:MaxGCPauseMillis` 参数控制最大垃圾收集停顿时间。允许的值是一个大于0的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。

`-XX:GCTimeRatio` 参数直接设置吞吐量大小。它的值应该是一个大于0且小于100的整数。如果把此参数设置为19，那允许的最大GC时间就占总时间的5%（即 1/(1+19)），此参数的默认值为99。

`-XX:+UseAdaptiveSizePolicy` 这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC **自适应的调节** 策略。自适应调节策略也是Parallel Scavenge 收集器与ParNew收集器的一个重要区别。

## 4.Serial Old收集器

Serial Old收集器是Serial收集器的老年代版本，它同样是一个单线程收集器，使用 **标记-整理** 算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK 1.5之前的版本中与Parallel Scavenge收集器搭配使用，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。

## 5.Parallel Old收集器

Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和 **标记-整理**算法。在这个收集器出现之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。原因是，如果新生代选择了Parallel Scavenge收集器，老年代除了选择Serial Old收集器外别无选择。由于老年代Serial Old收集器在服务端应用性能上的拖累，使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew+CMS的组合给力。

直到Parallel Old收集器出现后，**吞吐量优先** 收集器终于有了比较名副其实的应用组合，在 **注重吞吐量以及CPU资源敏感** 的场合，都可以优先考虑Parallel Scavenge + Parallel Old收集器。

## 6.CMS（Concurrent Mark Sweep）收集器

CMS收集器是在JDK 1.5时期，HotSpot推出的一款在强交互应用中几乎可以认为有划时代意义的垃圾收集器。这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。

CMS收集器是一种以 **获取最短回收停顿时间** 为目标的收集器。目前很大一部分的Java应用集中在互联网或者B/S系统的服务端上。

CMS收集器是基于 **标记-清除** 算法实现的，它的运作过程分为4个步骤，包括：**初始标记**、**并发标记**、**重新标记**和**并发清除**。

其中，初始标记、重新标记这两步骤仍然需要 **Stop The World**。**初始标记** 仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。**并发标记** 阶段就是进行GC RootsTracing的过程。而 **重新标记** 阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。

由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。

CMS是一款优秀的收集器，它的主要优点是：并发收集、低停顿。但是还达不到完美的程度，它有以下3个明显的缺点：

1) CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量降低。

2) CMS收集器无法处理 **浮动垃圾**，可能出现 **Concurrent Mode Failure** 失败而导致另一次Full GC[^4]的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为 **浮动垃圾**。

3) CMS是一款基于 **标记-清除** 算法实现的收集器，收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大剩余空间，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。为了解决这个问题，CMS收集器提供一了个-XX:UseCMSCompactAtFullCollection开关参数（默认是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但是停顿时间不得不变长。虚拟机设计者还提供了另外一参数-XX:CMSFullGCsBeforeCompaction这个参数用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）。

## 7.G1收集器（Garbage-First）

G1收集器是当今收集器技术发展的最前沿成果之一，是一款面向服务端的垃圾收集器。与其他GC收集器相比，G1具备如下特点：

### 1.并行与并发

G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop the World停顿的时间。

### 2.分代收集

G1采用与其他收集器不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。

### 3.空间整合

G1从整体来看是基于 **标记-整理** 算法实现的收集器，从局部来看是基于 **复制** 算法实现的。但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到内存空间而提前触发下一次GC。

### 4.可预测的停顿

G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。

使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，安将整个Java堆划分为多个大小相等的独立区域(Region)，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分区域（不需要连续）的集合。

G1可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个区域里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的区域。这种使用区域划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。

虽然把Java堆分为多个区域，但是区域不可能是孤立的，一个对象分配在某个区域后，它还是可以与整个Java堆任意的对象发生引用关系。那在做可达性判定对象是否存活的时候，岂不是还得描述整个Java堆才能保证准确性？实际上在G1收集器中是不需要对全堆扫描的。在G1收集器中，区域之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。G1中每个区域都有一个与之对应的Remember Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的区域中（在分代的例子中就是检查是否老年代的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的区域的Remembered Set之中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。

如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：

### 1.初始标记

初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS(Next Top at Mark Start)的值。让下阶段用户程序并发运行时，能在正确可用的区域中创建新对象，这阶段需要停顿线程，但耗时很短。

### 2.并发标记

并发标记阶段是从GC Roots开始对堆中对象进行可达性分析，找出存活对象，这阶段耗时较长，但可与用户程序并发执行。

### 3.最终标记

最终标记阶段是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Rememberd Set中，这阶段需要停顿线程，但是可并行执行。

### 4.筛选回收

在筛选回收阶段首先对各处区域回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分区域，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。

## 8.垃圾收集器参数总结

下表整理了虚拟机非稳定的运行参数可供实战时参考：

![JVM](/assets/jvm/3/02.png)
![JVM](/assets/jvm/3/03.png)

# 六、内存分配与回收策略

Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。

接下来将会讲解几条最普遍的内存分配规则，并通过代码去验证这些规则。

## 1.对象优先在Eden分配

大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC[^5]。

```java
/**
 * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8
 *
 */
public class MinorGC {
	private static final int _1MB = 1024*1024;
	
	public static void testAllocation() {
		byte[] allocation1, allocation2, allocation3, allocation4;
		allocation1 = new byte[2*_1MB];
		allocation2 = new byte[2*_1MB];
		allocation3 = new byte[2*_1MB];
		allocation4 = new byte[4*_1MB];//出现一次Minor GC
	}

	public static void main(String[] args) {
		testAllocation();
	}
}
```

运行结果:

```
[GC[DefNew：6651K->148K(9216K),0.0070106 secs]6651K->6292K(19456K),0.0070426 secs][Times：user=0.00 sys=0.00,real=0.00 secs]
Heap
 PSYoungGen      total 9216K, used 7455K ...
  eden space 8192K, 91% used ...
  from space 1024K, 0% used ...
  to   space 1024K, 0% used ...
 ParOldGen       total 10240K, used 4096K ...
  object space 10240K, 40% used ...
 Metaspace       used 2759K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 305K, capacity 386K, committed 512K, reserved 1048576K
```

testAllocation()方法中，尝试分配3个2MB大小和1个4MB大小的对象，在运行时通过-Xms20M、-Xmx20M、-Xmn10M这3个参数限制了Java堆大小为20MB，不可扩展，其中10MB分配给新生代，剩下的10MB分配给老年代。-XX:SurvivorRatio=8决定了新生代中Eden区与一个Survivor区的空间比例是8:1，从输出的结果也可看到 `eden space 8192K`、`from space 1024K`、`to   space 1024K`的信息，新生代总可用空间为9216K(Eden区+1个Survivor区的总容量)。

执行testAllocation()中分配allocation4对象的语句时会发生一次Minor GC，这次GC的结果是新生代6651K变为148K,而总内存占用量则几乎没有减少（因为allocation1、allocation2、allocation3三个对象都是存活的，虚拟机几乎没有找到可回收的对象）。这次GC发生的原因是给allocation4分配内存的时候，发现Eden已经被占用了6MB，剩余空间已不足以分配allocation4所需的4MB内存，因此发生Minor GC。GC期间虚拟又发现已有的3个2MB大小的对象全部无法放入Survivor空间，所以只好通过分配担保机制提前转移到老年代去。

这次GC结束后，4MB的allocation4对象顺序分配在Eden中，因此程序执行完的结果是Eden占用4MB(被allocation4占用)，Survivor空闲，老年代被占用6MB(被allocation1、allocation2、allocation3占用)。

## 2.大对象直接进入老年代

大对象[^6] 对虚拟机的内存分配来说就是一个坏消息，更坏的消息是遇到一群 **短命大对象**，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来安置它们。

虚拟机提供了一个 `-XX:PretenureSizeThreshold` 参数，令大于这个设置值的对象直接在老年代中分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。

```java
/**
 * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails
 * -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=3145728 -XX:+UseSerialGC
 */
public class MemoryTest {
	private static final int _1MB = 1024*1024;
	
	public static void testPretenureSizeThreshold() {
		byte[] allocation;
		allocation = new byte[4*_1MB];
	}

	public static void main(String[] args) {
		testPretenureSizeThreshold();
	}
}
```

运行结果:

```
Heap
 def new generation   total 9216K, used 1311K ...
  eden space 8192K,  16% used ...
  from space 1024K,   0% used ...
  to   space 1024K,   0% used ...
 tenured generation   total 10240K, used 4096K ...
   the space 10240K,  40% used ...
 Metaspace       used 2758K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 305K, capacity 386K, committed 512K, reserved 1048576K
```

执行testPretenureSizeThreshold()方法后，我们看到Eden空间几乎没有被使用，而老年代的10MB空间被使用了4MB，也就是allocation对象直接就分配在老年代中，这是因为PretenureSizeThreshold被设置为3MB，因此超过3MB的对象都会直接在老年代进行分配。

注意：PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数，Parallel Scavenge收集器一般并不需要设置。如果遇到必须使用此参数的场合，可以考虑ParNew+CMS的收集器组合。

## 3.长期存活的对象将进入老年代

为了能够识别哪些对象应该放在新生代，哪些对象应该放在老年代，虚拟机给每个对象定义了一个对象年龄计数器，如果对象在Eden出生并经过一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每 **熬过** 一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，可通过-XX:MaxTenuringThreshold参数设置）将会被晋升到老年代中。

## 4.动态对象年龄判定

为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可在直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。

## 5.空间分配担保

在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于 **历次晋升到老年代对象的平均大小**，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设计不允许冒险，那这时也要改为进行一次Full GC。在JDK 6 Update24之后，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。

# 总结

本文介绍了垃圾收集的算法，几款JDK 1.7中提供的垃圾收集器特点以及运作原理。通过代码实例验证了Java虚拟机中自动内存分配及回收的主要规则。

内存回收与垃圾收集在很多时候都是影响系统性能、并发能力的主要因素之一，虚拟机之所以提供多种不同的收集器以及提供大量的调节参数，是因为只有根据实际应用需求、实现方式选择最优的收集方式才能获取最高的性能。


[^1]: **并行** 指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。

[^2]: **并发** 指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。

[^3]: **吞吐量** 所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。即：吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)。

[^4]: **老年代GC(Major GC/Full GC)** 指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC(但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。Major GC的速度一般会比Minor GC慢10倍以上。

[^5]: **新生代GC(Minor GC)** 指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕来的特性，所以Minor GC非常频繁，一般回收速度也比较快。

[^6]: 所谓 **大对象** 是指，需要大量连续内存空间的Java对象。
