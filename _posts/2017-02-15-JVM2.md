---
date: 2017/2/15 星期三  11:35:35+0800
layout: post
title: 深入理解Java虚拟机(2)-Java内存区域与内存溢出异常
thread: 164
categories: 读书笔记
tags:  深入理解Java虚拟机
---

本篇主要介绍虚拟机中内存是如何划分的，以及哪部分区域、什么样的代码和操作可能导致内存溢出异常，并讲解了各个区域出现内存异常的常见原因。

# 一、运行时数据区域

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间。Java虚拟机所管理的内存将会包括以下几个运行时数据区域。

![JVM](/assets/jvm/2/01.png)

## 1.程序计数器

**程序计数器**是一块较小的内存空间，可看作是当前线程所执行的字节码的行号指示器。字节码工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。

在多线程环境下，每条线程都有一个独立的程序计数器，各线程之间计数器互不影响，独立存储。

此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

## 2.Java虚拟机栈

Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧[^1]用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，都对应着一个栈帧在虚拟机入栈到出栈的过程。

Java内存区按粗糙的分法可分为**堆内存**和**栈内存**，其中**堆**会在后面专门介绍，而**栈**就是虚拟机栈，或者说是虚拟机栈中**局部变量表**部分。

局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型（指向了一条字节码指令的地址）。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

在Java虚拟机规范中，对这个区域规定了两种异常状况：

- 如果线程请求的深度大小虚拟机所允许的深度，将抛出StackOverflowError异常；
- 如果虚拟机栈可动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

## 3.本地方法栈

本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。

与虚拟机栈一样，本地方法栈区也会抛出StackOverflowError和OutOfMemoryError异常。

## 4.Java堆

对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域。在虚拟机启动时创建。此内存区域的唯一目的就是存放对象，几乎所有的对象实例都在这里分配。

如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。

## 5.方法区

方法区是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

## 6.运行时常量池

运行时常量池是方法区的一部分。Class文件中除了类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。

既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemory异常。

## 7.直接内存

直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用。

NIO类引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

本机直接内存的分配不会受到堆大小的限制，但是会受到本机总内存大小及处理器寻址空间的限制。服务管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError异常。

# 二、HotSpot虚拟机对象探秘

本节以常用的虚拟机HotSpot和常用的内存区域Java堆为例，深入探讨HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。

## 1.对象的创建

### 虚拟机中对象的创建过程

1)虚拟机遇到一条new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过程。如果没有，那必须先执行相应的类加载过程。

2)在类加载完检查通过后，接下来虚拟机将为新生对象分配内存。（指针碰撞和空闲列表）

3)内存分配完成后，虚拟机需要将分配的内存空间都初始化为零值。

4)接下来，虚拟机要对对象进行必要的设置。例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。

在上面工作都完成之后，从虚拟机视角来看，一个新的对象已经产生了。但从Java程序的视角来看，对象创建才刚刚开始。(init方法还没有执行，所有的字段都还为零)。所以，一般来说，执行new指令之后会接着执行init方法进行初始化，这样一个真正可用的对象才算完全产生出来。

## 2.对象的内存布局

在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头、实例数据和对齐填充。

### 对象头

HotSpot虚拟机的对象头包括两部分信息：

一部分用于存储对象自身的运行时数据。如哈希码、GC分代年龄、锁状标志、线程持有的锁、偏向线程ID、偏向时间戳等。对象头信息是与对象自身定义的数据无关的额外存储成本。

另一部分是类型指针。即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息不一定要经过对象本身。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。

### 实例数据

实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配策略是把相同宽度的字段分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。

### 对齐填充

对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正是8字节的整数倍，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

## 3.对象的访问定位

建立对象是为了使用对象，我们的Java程序需要通过reference数据来操作堆上的具体对象。对象的访问方式取决于虚拟机的实现方式。目前主流的访问方式有使用句柄和直接指针两种。

### 使用句柄

如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。

![JVM](/assets/jvm/2/02.png)

### 使用直接指针

如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如果放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。

![JVM](/assets/jvm/2/03.png)

这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。

使用直接指针访问方式的最大好处就是速度更快，它节省了一次指定位的时间开销。

就虚拟机Sun HotSpot而言，它是使用第二种方式进行对象访问的。

# 三、实战：OutOfMemoryError异常

本节将通过若干实例来验证异常发生的场景，并且会初步介绍几个与内存相关的最基本的虚拟机参数。

本节内容的目的有两个：第一，通过代码验证Java虚拟机规范中描述的各个运行时区域存储的内容；第二希望在工作中遇到实际的内存溢出异常时，能根据异常的信息快速判断是哪个区域的内存溢出，知道什么样的代码可能会导致这些区域内存溢出，以及出现这些异常后该如何处理。

## 1.Java堆溢出

Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。

下面代码限制Java堆的大小为20M，不可扩展（将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展）,通过参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后进行分析。

```java
/**
 * VM Args：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
 * 
 */

public class HeapOOM {
	static class OOMObject{}

	public static void main(String[] args) {
		List<OOMObject> list = new ArrayList<OOMObject>();
		while(true) {
			list.add(new OOMObject());
		}
	}
}

```

运行结果：

```
java.lang.OutOfMemoryError: Java heap space
Dumping heap to java_pid16996.hprof ...
Heap dump file created [27999691 bytes in 0.177 secs]
```

注释中 `VM Args` 后面跟着的参数代表程序执行时所需设置的虚拟机启动参数。

Java堆内存的OOM异常(OutOfMemoryError)是实际应用中常见的内存溢出异常情况。要解决这个区域的异常，一般的手段是先通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。

如果是内存泄漏，可进一步通过工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们。掌握了泄露对象的类型信息及GC Roots引用链的信息，就可以比较准确地定位出泄露代码的位置。

如果不存在泄露，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms）,与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序动行期的内存消耗。

## 2.虚拟机和本地方法栈溢出

由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于HotSpot来说，虽然-Xoss参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由-Xss参数设定。

在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。

如果不限于单线程，通过不断地建立线程的方式倒是可以产生内存溢出异常，但是这样产生的溢出异常与栈空间是否足够大并不存在任何联系，或者准确地说，在这种情况下，为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。

当出现StackOverflowError异常时有错误堆栈可以阅读，相对来说，比较容易找到问题的所在。而且，如果使用虚拟机默认参数，栈深度在**大多数**情况下达到1000~2000完全没有问题。但是，如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。

## 3.方法区和运行时常量池溢出

方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这些区域的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。

方法区溢出也是一种常见的内存溢出异常，一个类要被垃圾收集器回收，判定条件是比较苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。

## 4.本机直接内存溢出

DirectMemory容量可通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值（-Xmx指定）一样。

由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果我们发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。

# 总结

本篇介绍了虚拟机中的内存是如何划分的，哪部分区域、什么样的代码和操作可能导致内存溢出异常。

[^1]: 栈帧是方法运行时的基础数据结构。