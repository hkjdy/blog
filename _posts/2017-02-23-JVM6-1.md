---
date: 2017/2/23 星期四  12:10:53+0800
layout: post
title: 深入理解Java虚拟机(6)-Class类文件结构
thread: 164
categories: 读书笔记
tags:  深入理解Java虚拟机
---

本文将要介绍Class文件结构中的各个组成部分，以及每个部分的定义、数据结构。

# 一、无关性的基石

Java在刚刚诞生之时曾经提出一个非常著名的宣传口号：一次编写，到处运行。“与平台无关”的理想最终实现在操作系统的应用层上：Sun公司以及其他虚拟机提供商发布了许多可以运行在各种不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现程序的“一次编写，到处运行”。

## 1.平台无关性

各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——字节码是构成平台无关性的基石。

## 2.语言关性

实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联。基于安全方面的考虑，Java虚拟机规范要求Class文件中使用许多强制性的语法和结构化约束。作为一个通用的、机器无关的执行平台，任何其他语言的实现者都可以将Java虚拟机作为语言的产品交付媒介。例如，使用Java编译器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他语言的编译器一样可以把程序代码编译成Class文件，虚拟机并不关心Class的来源是何种语言。如下图所示：

![JVM](/assets/jvm/6/01.png)

# 二、Class类文件的结构

解析Class文件的数据结构是本文的主要内容。Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上的空间数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。

根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：**无符号和表**，后面的解析都要以这两种数据类型为基础，所以这里要先介绍这两个概念。

- 无符号数

无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。

- 表

表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表，它由下表所示的数据项构成。

![JVM](/assets/jvm/6/02.png)

无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型的集合。接下来看看这个表中各个数据项的具体含义。

## 1.魔数与Class文件的版本

每个Class文件的头4个字节称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。魔数主要是用来识别文件身份，比用扩展名来识别文件身份更安全，因为文件扩展名可随意修改。Class文件的魔数值为：0xCAFEBABE(咖啡宝贝)。下图是HelloWorld.class文件的内容：

![JVM](/assets/jvm/6/03.png)

紧接着魔数的4个字节存储的是Class文件和版本号：第5和第6字节是次版本号(00 00)，第7和第8字节是主版本号(00 34)。这里十六进制值，转换成十进制后Class文件的版本号为:52.0。Java的版本号是从45开始的，52.0代表的是JDK 1.8。高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，即使文件格式未发生变化，虚拟机也必须拒绝执行超过其版本号的Class文件。

下表列出了主流JDK版本编译器与Class文件版本号对应关系：

![JVM](/assets/jvm/6/04.png)

## 2.常量池

紧接着主次版本号之后的是常量池入口，常量池可理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时它还是在Class文件中第一个出现的表类型数据项目。

由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值(constant_pool_count)。与Java中语言习惯不一样的是，这个容量计数是从1而不是从0开始的，上图中常量池容量为十六进制0x0022，即十进制的34，这代表常量池中有33项常量，索引范围为1~33。这样做的目的在于满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况就可以把索引值置为0来表示。Class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型都是从0开始的。

常量池中主要存放两大类常量：字面量和符号引用。字面量比较接近于Java语言层面的常量概念。如文本字符串、声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括了下面三类量：

- 类和接口的全限定名
- 字段的名称的描述符
- 方法的名称和描述符

## 3.访问标志

在常量池结束后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。具体的标志位以及标志的含义见下表：

![JVM](/assets/jvm/6/05.png)

本例中，HelloWorld是一个普通Java类，被public关键字修饰，没有被声明为final和abstract，使用JDK 1.8编译，不是接口、枚举或注解，因此它的ACC_PUBLIC、ACC_SUPER标志应该为真，其余为假。所以它的access_flags的值应该为:0x0001|0x0021=0x0021。从上图中可以看出，access_flags标志(偏移地址:0x00000190C)的确为0x0021。

## 4.类索引、父类索引与接口索引集合

Class文件中由类索引、父类索引和接口索引集合这三项数据来确定这个类的继承关系。

- 类索引用于确定个类的全限定名。
- 父类索引用于确定这个类的父类的全限定名。除了java.lang.Object外，所有Java类的父类索引都不为0。
- 接口索引集合就是用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）的接口顺序从左到右排列在接口索引集合中。

类索引、父类索引和接口索引集合都按顺序排列在访问标志之后。

- 类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限制名字符串。

- 对于接口索引集合，入口的第一项——u2类型的数据为接口计数器，表示索引的容量，如果该类没有实现任何接口，则该计数器值为0，后面接口的索引不再占用任何字节。

## 5.字段表集合

字段表用于描述接口或类中声明的变量。字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。

Java中描述一个字段可以包含的信息有：

- 字段的作用域(public、private、protected修饰符)。
- 是实例变量还是类变量(static修饰符)。
- 可变性(final)。
- 并发可见性(volatile修饰符，是否强制从主内存读写)。
- 可否被序列化(transient修饰符)。
- 字段数据类型(基本类型、对象、数组)。
- 字段名称。

上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。字段表的最终格式如下：

![JVM](/assets/jvm/6/06.png)

字段修饰拊放在access_flags项目中，跟随access_flags标志的是两项索引值：name_index和descriptor_index。它们都是对常量池的引用。分别代表着字段的简单名称以及字段和方法的描述符[^1]。字段表所包含的固定数据项目到description_index为止就结束了，不过在description_index之后跟随着一个属性表集合用于存储一些额外的信息，字段都可以在属性表中描述零至多项的额外信息。

字段表集合中不会列出从超类或者父类中继承而来的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。另外，在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段第一名就是合法的。

## 6.方法表集合

Class文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式，方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项，这些数据项目的含义也非常类似，仅在访问标志和属性表集合的可选项中有所区别。

![JVM](/assets/jvm/6/07.png)

## 7.属性表集合

在Class文件中、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。

与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松了一些，不再要求各个属性表具有严格顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。属性表结构如下：

![JVM](/assets/jvm/6/08.png)

EOF

[^1]:描述符的作用是用来描述字段的数据类型、方法的参数列表(包括数量类型以及顺序)和返回值。