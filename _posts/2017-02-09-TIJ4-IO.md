---
date: 2017/2/9 星期四  17:16:14+0800
layout: post
title: Java编程思想-Java I/O系统
thread: 164
categories: 读书笔记
tags:  Java编程思想
---

本文介绍Java标准类库中各种各样的I/O类及它们的用法。

## File类

File（文件）类既能代表一个特定文件的名称，又能代表一个目录下的一组文件的名称。如果它指的是一个文件集，我们就可以对此集合调用list()方法，这个方法返回一个字符数组。

假设我们想查看一个目录列表，可以用两种方法来使用File对象。

第一种方法：调用不带参数的list()方法，便可获得此File对象包含的全部列表。

```java
public class DirList {
	public static void main(String[] args) {
		File path = new File(".");
		String[] list = path.list();
		
		for(String dirItem : list) {
			System.out.println(dirItem);
		}
	}
}

```

运行结果

```
.classpath
.project
.settings
bin
src
```


第二种方法：调用带参数的list()方法，返回一个满足条件的列表。

```java
import java.io.File;
import java.io.FilenameFilter;
import java.util.regex.Pattern;

class DirFilter implements FilenameFilter {
	private Pattern pattern;
	public DirFilter(String regex) {
		pattern = Pattern.compile(regex);
	}

	@Override
	public boolean accept(File dir, String name) {
		return pattern.matcher(name).matches();
	}
}

public class DirList {
	public static void main(String[] args) {
		File path = new File(".");
		String[] list = path.list(new DirFilter("[a-zA-Z]+"));
		
		for(String dirItem : list) {
			System.out.println(dirItem);
		}		
	}
}

```

运行结果

```
bin
src
```

list()方法会为此目录对象下的每个文件名调用accept()，来判断该文件是否包含在返回列表中。

### File方法

File类不仅只代表存在的文件或目录。也可以用File对象来创建新的目录或不存在的整个目录路径。我们还可以查看文件的特性，程序清单如下：

```java
public class TestFile {
	public static void main(String[] args) {
		File f = new File("hkjdy");
		if(f.exists()) {
			System.out.println("isDirectory: " + f.isDirectory());
			System.out.println("isFile: " + f.isFile());
			System.out.println("getAbsolutePath: " + f.getAbsolutePath());
			System.out.println("getName: " + f.getName());
			System.out.println("lastModified: " + f.lastModified());
			System.out.println("canRead: " + f.canRead());
			System.out.println("canWrite: " + f.canWrite());
		} else {
			f.mkdir();
		}

		File f1 = new File("hkjdy/a/b/c/d/e/f");
		if(!f1.exists()) {
			f1.mkdirs();
		}
	}
}
```

运行结果

```
isDirectory: true
isFile: false
getAbsolutePath: G:\workspace\test\TIJ4\hkjdy
getName: hkjdy
lastModified: 1486520356838
canRead: true
canWrite: true
```

## 输入和输出

### InputStream类型

InputStream的作用是用来表示那些从不同数据源产生输入的类。这些数据源包括：

1. ByteArrayInputStream（字节数组）：允许将内存的缓冲区当作InputStream使用。
2. StringBufferInputStream(String对象）：将String转换成InputStream。
3. FileInputStream（文件）：用于从文件中读取信息。
4. PipedInputStream(管道)：产生用于写入相关PipedInputStream的数据。实现**管道化**概念。
5. SequenceInputStream：一个由其他种类的流组成的序列。将两个或多个InputStream对象转换成单一InputStream。
6. 其他数据源，如Internet连接等。

### OutputStream类型

OutputStream类型的类决定了输出所要去往的目标：字节数组，文件或管道。

1. ByteArrayOutputStream：在内存中创建缓冲区。所有送往**流**的数据都要放置在此缓冲区。
2. FileOutputStream：用于将信息写至文件。
3. PipedOutputStream：任何写入其中的信息都会自动作为相关PipedInputStream的输出。实现“管道化”概念。
4. FilterOutputStream：抽象类，作为“装饰器”的接口。其中，**装饰器**为其他OutputStream提供有用功能。

## 添加属性和有用的接口

### 通过FilterInputStream从InputStream读取数据

FilterInputStream类能够完成两件完全不同的事情：

1. DataInputStream允许我们读取不同的基本类型数据以及String对象（所有方法都以**read**开头，例如readByte()、readFloat()等等）。构造函数:DataInputStream(InputStream in)。
2. 其他FilterInputStream类则在内部修改InputStream的行为方式：是否缓冲，是否保留它所读过的行，以及是否把单一字符推回输入流等等。


FilterInputStream类型如下：

1. DataInputStream：与DataOutputStream搭配使用，因此我们可以按照可移植方式从流读取基本数据类型(int,char,long)等。
2. BufferedInputStream：使用它可以防止每次读取时都得进行实际写操作。代表**使用缓冲区**。
3. LineNumberInputStream：跟踪输入流中的行号；可调用getLineNumber()和setLineNumber(int)。
4. PushbackInputStream：具有**能弹出一个字节的缓冲区**。因此可以将读到的最后一个字符回退。

### 通过FilterOutputStream向OutputStream写入数据

1. 与DataInputStream对应的是DataOutputStream，它可以将各种基本数据类型以及String对象格式化到输出到**流**中；这样一来，任何机器上的任何DataInputStream都能够读取它们。所有方法都以**write**开头，例如writeByte()、writeFloat()等。

2. BufferedOutputStream是一个修改过的OutputStream，它对数据流使用缓冲技术；因此当每次向流写入时，不必每次都进行实际的物理写动作。所以在进行输出时，我们可能更经常的是使用它。

## Reader和Writer

设计Reader和Writer继承层次结构主要是为了国际化。InputStream和OutputStream继承层次结构仅支持8位字节流，并且不能很好地处理16位的Unicode字符。由于Unicode用于字符国际化，所以添加Reader和Writer继承层次结构就是为了在所有的I/O操作中都支持Unicode。另外，新类库的设计使得它的操作比旧类库更快。

Reader和Writer面向字符，而InputStream和OutputStream面向字节。在开发过程中，最明智的做法是尽量**尝试**使用Reader和Writer，一旦程序代码无法成功编译，我们就会发现自己不得不使用面向字节的类库。

## 自我独立的类RandomAccessFile

RandomAccessFile适用于大小已知的记录组成的文件，所以我们可以使用seek()将记录从一处转移到另一处，然后读取或者修改记录。

RandomAccessFile是一个完全独立的类，除了实现DataInput和DataOutput接口之外，它和InputStream或者OutputStream这两个类继承层次结构没有任何关联。这么做是因为RandomAccessFile拥有和别的I/O类型本质不同的行为，因为我们可以在一个文件内向前和向后移动。在任何情况下，它都是自我独立的，直接从Object派生而来。

## I/O流的典型使用方式

### 1.缓冲输入文件

如果想要打开一个文件用于字符输入，可以使用以String或File对象作为文件名的FileInputReader。为了提高速度，我们希望对那个文件进行缓冲，那么我们将所产生的引用传给一个BufferedReader构造器。

```java
public class BufferedInputFile {
	public static String read(String filename) throws IOException {
		BufferedReader in = new BufferedReader(new FileReader(filename));
		String s;
		StringBuilder sb = new StringBuilder();
		//当readLine()返回null时，就达到了文件的末尾
		while((s = in.readLine()) !=  null) {
			sb.append(s +"\n");
		}
		in.close();
		
		return sb.toString();
	}
	
	public static void main(String[] args) throws IOException {
		System.out.println(read("data.txt"));
	}
}

```

### 2.从内存输入

在下面的示例中，从BufferedInputFile.read()读入的String结果被用来创建一个StringReader。然后调用read()每次读取一个字符，并把它发送到控制台。

```java
public class MemoryInput {
	public static void main(String[] args) throws IOException {
		
		StringReader in = new StringReader(BufferedInputFile.read("data.txt"));
		int c;
		while( (c = in.read()) != -1) {
			System.out.print((char)c);
		}
		
	}
}
```

### 3.格式化的内存输入

要读取格式化数据，可以使用DataInputStream，它是一个面向字节的I/O类。因此我们必须使用InputStream类而不是Reader类。

下面这个例子演示了怎样一次一个字节地读取文件：

```java
public class TestEOF {
	public static void main(String[] args) throws IOException {
		DataInputStream in = new DataInputStream(
				new BufferedInputStream(
						new FileInputStream("data.txt")));
		while(in.available() != 0) {
			System.out.print((char)in.readByte());
		}
		
	}
}
```

### 4.基本的文件输出

FileWriter对象可以向文件写入数据。首先，创建一个与指定文件连接的FileWriter。实际上，我们通常会用BufferedWriter将其包装起来用以缓冲输出。在本例中，为了格式化机制，它被装饰成了PrintWriter。按照这种方式创建的数据文件可以作为普通文本文件读取。

```java
public class BasicFileOutput {

	public static void main(String[] args) throws IOException {
		PrintWriter out = new PrintWriter(
				new BufferedWriter(new FileWriter("data.out")));
		for(int i=0; i<5; i++) {
			out.println("line number " + i);
		}
		//显式调用close()，如果我们不为所有的输出文件调用close()
		//就会发现缓冲区内容不会被刷新清空，那么它们也就不完整
		out.close();
	}
}
```

Java SE5在PrintWriter中添加了一个辅助构造器，使用你不必在每次希望创建文本文件并向其中写入时，都去执行所有的装饰工作。下面是用这种快捷方式重写的BasicFileOutput.java:

```java
public class BasicFileOutput {

	public static void main(String[] args) throws IOException {
		PrintWriter out = new PrintWriter("data.out");
		for(int i=0; i<5; i++) {
			out.println("line number " + i);
		}
		out.close();
	}
}

```

这里仍旧是在进行缓存，只是不必自己去实现。

### 5.存储和恢复数据

PrintWriter可以对数据进行格式化，以便人们的阅读。但是为了输出可供另一个**流**恢复的数据，我们需要用DataOutputStream写入数据，并用DataInputStream恢复数据。程序清单如下：

```java
public class StoringAndRecoveringData {

	public static void main(String[] args) throws IOException {
		DataOutputStream out = new DataOutputStream(
				new BufferedOutputStream(
						new FileOutputStream("data.txt")));
		out.writeDouble(3.14159);
		out.writeUTF("That was pi");
		out.close();
		
		DataInputStream in = new DataInputStream(
				new BufferedInputStream(
						new FileInputStream("data.txt")));
		
		System.out.println(in.readDouble());
		System.out.println(in.readUTF());
	}
}
```

### 6.读写随机访问文件

使用RandomAccessFile，类似于组合使用了DataInputStream和DataOutputStream（因为它实现了相同的接口：DataInput和DataOutput）。另外我们可以看到，得用seek()可以在文件中到处移动，并修改文件中的某个值。

```java
public class UsingRandomAccessFile {
	static String fileName = "data.dat";
	
	static void display() throws IOException {
		RandomAccessFile rf = new RandomAccessFile(fileName, "r");
		System.out.println("--------------");
		for(int i=0; i<7; i++) {
			System.out.println("Value " + i +": " + rf.readDouble());
		}
		System.out.println("--------------");
		rf.close();
	}
	
	public static void main(String[] args) throws IOException {
		RandomAccessFile rf = new RandomAccessFile(fileName, "rw");
		for(int i=0; i<7; i++) {
			rf.writeDouble(i*1.414);
		}		
		rf.close();
		display();
		
		rf = new RandomAccessFile(fileName, "rw");
		//因为double总共8字节长，所以只需用5*8来产生查找位置
		rf.seek(5*8);
		rf.writeDouble(47.0001);
		rf.close();
		display();
	}
}
```

运行结果

```
--------------
Value 0: 0.0
Value 1: 1.414
Value 2: 2.828
Value 3: 4.242
Value 4: 5.656
Value 5: 7.069999999999999
Value 6: 8.484
--------------
--------------
Value 0: 0.0
Value 1: 1.414
Value 2: 2.828
Value 3: 4.242
Value 4: 5.656
Value 5: 47.0001
Value 6: 8.484
--------------
```

## 标准I/O

### 1.从标准输入中读取

通常我们会用readLine()一次一行地读取输入，为此，我们将System.in包装成BufferedReader来使用，这要求我们必须用InputStreamReader把System.in转换成Reader。下面这个例子将直接回显你所输入的每一行。

```java
public class Echo {

	public static void main(String[] args) throws IOException {
		BufferedReader stdin = new BufferedReader(
				new InputStreamReader(System.in));
		String s;
		while((s = stdin.readLine()) != null && s.length() != 0) {
			System.out.println(s);
		}
	}

}

```

### 2.将System.out转换成PrintWriter

System.out是一个PrintStream，而PrintStream是一个OutputStream。PrintWriter有一个可以接受OutputStream作为参数的构造器。因此，只要需要，就可以使用那个构造器把System.out转换成PrintWriter。

```java
public class ChangeSystemOut {

	public static void main(String[] args) {
		PrintWriter out = new PrintWriter(System.out, true);
		out.println("Hello World!");
	}
}

```

重要的是要使用有两个参数的PrintWriter的构造器，并将第二个构造器参数设为true，以便开启自动清空功能；否则，你可能看不到输出。

### 3.标准I/O重定向

Java的System类提供了一些简单的静态方法调用，以允许我们对标准输入、输出和错误I/O流进行重定向：

- setIn(InputStream)
- setOut(PrintStream)
- setErr(PrintStream)

下面的示例简单演示了这些方法的使用：

```java
public class Redirecting {

	public static void main(String[] args) throws IOException {
		
		PrintStream console = System.out;
		BufferedInputStream in = new BufferedInputStream(
				new FileInputStream("data.txt"));
		
		PrintStream out = new PrintStream(
				new BufferedOutputStream(
						new FileOutputStream("test.out")));
		
		System.setIn(in);
		System.setOut(out);
		System.setErr(out);
		
		BufferedReader br = new BufferedReader(
				new InputStreamReader(System.in));
		String s;
		while( (s = br.readLine()) != null) {
			System.out.println(s);
		}
		out.close();
		System.setOut(console);

	}

}
```

这个程序将标准输入附接到文件上，并将标准输出和标准错误重定向到另一个文件。

I/O重定向操纵的是字节流，而不是字符流，因此我们使用的是InputStream和OutputStream，而不是Reader和Writer。

## 新I/O

引进新I/O是为了改进性能及功能。而速度的提高来自于所使用的结构更接近于操作系统执行I/O的方式：**通道和缓冲器**。

唯一直接与通道交互的缓冲器是ByteBuffer——也就是说，可以存储未加工字节的缓冲器。ByteBuffer是相当基础的类：通过告知分配多少存储空间来创建一个ByteBuffer对象，并且还有一个方法选择集，用于以原始的字节形式或基本数据类型输出和读取数据。但是，没办法输出或读取对象，即使是字符串对象也不行。

旧I/O类库中有三个类被修改了，用以产生FileChannel。这三个被修改的类是FileInputStream、FileOutputStream以及用于既读又写的RandomAccessFile。下面的简单实例演示了上面三种类型的流，用以产生可写的、可读可写的及可读的通道。

```java
public class GetChannel {
	private static final int BSIZE = 1024;
	public static void main(String[] args) throws IOException {
		FileChannel fc = new FileOutputStream("data.txt").getChannel();
		fc.write(ByteBuffer.wrap(("Some text\n").getBytes()));
		fc.close();
		
		fc = new RandomAccessFile("data.txt", "rw").getChannel();
		fc.position(fc.size());	//Move to the end
		fc.write(ByteBuffer.wrap("Some more".getBytes()));
		fc.close();
		
		fc = new FileInputStream("data.txt").getChannel();
		ByteBuffer buff = ByteBuffer.allocate(BSIZE);
		fc.read(buff);
		buff.flip();
		while(buff.hasRemaining()) {
			System.out.print((char)buff.get());
		}
	}
}
```

运行结果

```
Some text
Some more
```

对一过里所展示的任何流类，getChannel()。通道是一种相当基础的东西：可以向它传送用于读写的ByteBuffer，并且可以锁定文件的某些区域用于独占式访问。

除了可以使用warp()方法将已存在的字节数组**包装**到ByteBuffer中之外，还可以使用一种**put**方法直接对它们进行填充，填入一个或多个字节，或基本数据类型的值。

### 1.转换数据

在上面的演示程序中我们发现，为了输出文件中的信息，我们必须每次只读取一个字节的数据，然后将每个byte类型的数据强制转换成char类型。这种方法似乎有点原始，我们通过使用java.nio.CharBuffer类来解决这个问题，程序清单如下：

```java
public class BufferToText {
	private static final int BSIZE = 1024;
	public static void main(String[] args) throws IOException {
		FileChannel fc = new FileOutputStream("data2.txt").getChannel();
		fc.write(ByteBuffer.wrap("Some text".getBytes()));
		fc.close();
		
		fc = new FileInputStream("data2.txt").getChannel();
		ByteBuffer buff = ByteBuffer.allocate(BSIZE);
		fc.read(buff);
		buff.flip();
		//Doesn't work
		System.out.println(buff.asCharBuffer());
		buff.rewind();//返回到数据开始部分
		
		// #1
		String encoding = System.getProperty("file.encoding");
		System.out.println("Decoded using " + encoding + ": " + Charset.forName(encoding).decode(buff));
		
		// #2
		fc = new FileOutputStream("data2.txt").getChannel();
		fc.write(ByteBuffer.wrap("Some text".getBytes("UTF-16BE")));
		fc.close();
		
		fc = new FileInputStream("data2.txt").getChannel();
		buff.clear();
		fc.read(buff);
		buff.flip();
		System.out.println(buff.asCharBuffer());
		
		// #3
		fc = new FileOutputStream("data2.txt").getChannel();
		buff = ByteBuffer.allocate(24);
		buff.asCharBuffer().put("Some text");
		fc.write(buff);
		fc.close();
		
		fc = new FileInputStream("data2.txt").getChannel();
		buff.clear();
		fc.read(buff);
		buff.flip();
		System.out.print(buff.asCharBuffer());
	}
}
```

缓冲器容纳的是普通的字节，为了把它们转换成字符，我们要么在输入它们的时候对其进行编码，要么在将其从缓冲器输出时对它们进行解码。

### 2.获取基本类型

尽管ByteBuffer只能保存字节类型的数据，但是它具有可以从其所容纳的字节中产生出各种不同基本类型值的方法。示例如下：

```java
public class GetData {
	private static final int BSIZE = 1024;
	public static void main(String[] args) {
		ByteBuffer bb = ByteBuffer.allocate(BSIZE);
		int i = 0;
		//在分配一个ByteBuffer这后，
		//可以通过检测它的值来查看缓冲器的分配方式是否将其内容自动置零
		//结论：内容自动置零
		while(i++ < bb.limit()) {
			if(bb.get() != 0) {
				System.out.print("nonzero");
			}
		}
		bb.rewind();
		// #1
		bb.asCharBuffer().put("Howdy");
		char c;
		while( (c = bb.getChar()) != 0) {
			System.out.print(c + " ");
		}
		System.out.println();
		bb.rewind();
		
		// #2
		bb.asShortBuffer().put((short)100);
		System.out.println(bb.getShort());
		bb.rewind();
		
		// #3
		bb.asIntBuffer().put(101);
		System.out.println(bb.getInt());
		bb.rewind();
		
		// #4
		bb.asLongBuffer().put(102L);
		System.out.println(bb.getLong());
		bb.rewind();
		
		// #5
		bb.asFloatBuffer().put(103);
		System.out.println(bb.getFloat());
		bb.rewind();
		
		// #6
		bb.asDoubleBuffer().put(104);
		System.out.println(bb.getDouble());
		bb.rewind();
	}
}
```

运行结果

```
H o w d y 
100
101
102
103.0
104.0
```

向ByteBuffer插入基本类型数据的最简单方法是：利用asCharBuffer()、asShortBuffre()等获得该缓冲器上的视图，然后使用视图的put()方法。

### 3.视图缓冲器

视图缓冲器可以让我们通过某个特定的基本数据类型的视窗查看其底层的ByteBuffer。对视图的任何修改都会映射成为对ByteBuffer中数据的修改。

### 4.缓冲器的细节

Buffer由**数据**和可以高效地访问及操纵这些数据的四个**索引**组成，这四个索引是：mark(标记)、position(位置)、limit(界限)和capacity(容量)。下面是用于设置和复位索引以及查询它们的值的方法。

![list](/assets/tij4/buffer.png)

<a href="http://www.hkjdy.cn/assets/tij4/buffer.png" target="_blank">查看大图</a>

在缓冲器中插入和提取数据的方法会更新这些索引，用于反映所发生的变化。

### 5.内存映射文件

内存映射文件允许我们创建和修改那些因为太大而不能放入内存的文件。有了内存映射文件，我们就可以假定整个文件都放在内存中，而且可以完全把它当作非常大的数组来访问。这种方法极大地简化了用于修改文件的代码。

```java
public class LargeMappedFiles {
	static int length = 0x8FFFFFF;	//128M
	public static void main(String[] args) throws FileNotFoundException, IOException {
		MappedByteBuffer out = new RandomAccessFile("test.dat", "rw")
				.getChannel()	//获得该文件上的通道
				.map(FileChannel.MapMode.READ_WRITE, 0, length);
		for(int i=0; i<length; i++) {
			out.put((byte)'x');
		}
		
		System.out.println("Finished writing");
		for(int i=length/2; i<length/2+6; i++) {
			System.out.print((char)out.get(i));
		}
		
	}
}
```

运行结果

```
Finished writing
xxxxxx
```

MappedByteBuffer由ByteBuffer继承而来，因此它具有ByteBuffer的所有方法。前面程序中创建的文件为128M，这可能比操作系统所允许一次载入内存的空间大。但似乎我们可以一次访问整个文件，因为只有一部分文件放入了内存，文件的其他部分被交换了出去。用这种方式，很大的文件（可达2GB）也可以很容易地修改。注意底层操作系统的文件映射工具是用来最大化地提高性能。

尽管旧的I/O流在用nio实现后性能有所提高，但是**映射文件访问**往往可以更加显著地加快速度。

### 6.文件加锁

Java的文件加锁机制，允许我们同步访问某个共享资源的文件。不过，竞争同一文件的两个线程可能在不同的Java虚拟机上；或者一个是Java线程，另一个是操作系统中其他的某个本地线程。文件锁对其他的操作系统进行是可见的，因为Java的文件加锁直接映射到了本地操作系统的加锁工具。

下面是一个关于文件加锁的简单例子：

```java
public class FileLocking {
	public static void main(String[] args) throws IOException, InterruptedException {
		FileOutputStream fos = new FileOutputStream("data.txt");
		FileLock fl = fos.getChannel().tryLock();
		if(fl != null) {
			System.out.println("Locked File");
			Thread.sleep(10000L);
			fl.release();
			System.out.println("Released Lock");
		}
		fos.close();
	}
}
```

通过FileChannel调用tryLock()或lock()，就可以获得整个文件的FileLock。tryLock()是非阻塞的，它设法获取锁，但是如果不能获得，它将直接从方法调用返回。lock()是阻塞式的，它要阻塞进程直至锁可以获得，或调用lock()的线程中断，或调用lock()的通道关闭。使用FileLock.release()可以释放锁。

也可以使用如下方法对文件的一部分上锁：

```java
FileLock tryLock(long position, long size, boolean shared)
```

或者

```java
FileLock lock(long position, long size, boolean shared)
```

其中，第三个参数指定是否是共享锁。


## 对象序列化

Java的对象序列化将那些实现了Serializable接口的对象转换成一个字节序列，并能够在以后将这个字节序列完全恢复为原来的对象。

对象序列化的概念加入到语言中是为了支持两种主要特性：一是Java的远程调用方法（Remote Method Invocation，RMI）,它使存活于其他计算机上的对象使用起来就像是存活于本机上一样。当向远程对象发送消息时，需要通过对象序列化来传输参数和返回值。再者，对Java Beans来说，对象的序列化也是必需的。使用一个Bean时，一般情况下是在设计阶段对它的状态信息进行配置。这种状态信息必须保存下来，并在程序启动时进行后期恢复；这种具体工作就是由对象序列化完成的。

要序列化一个对象，首先要创建某些OutputStream对象，然后将其封装在一个ObjectOutputStream对象内。这时，只需要调用writeObject()即可将对象序列化，并将其发送给OutputStream。要反向进行该过程，需要将一个InputStream封装在ObjectInputStream内，然后调用readObject()。和往常一样，我们最后获得的是一个引用，它指向一个向上转型的Object，所以必须向下转型才能直接设置它们。


对象序列化不仅保存了对象的“全景图”，而且能追踪对象内所包含的所有引用，并保存那些对象，接着又能对对象内包含的每个这样的引用进行追踪；依次类推。

```java
class Data implements Serializable {
	
	private static final long serialVersionUID = -3330043073775197918L;
	private int n;
	public Data( int n ) {
		this.n = n;
	}
	
	public String toString() {
		return Integer.toString(n);
	}
}

public class Worm implements Serializable {

	private static final long serialVersionUID = 3325279370440540220L;
	
	private static Random rand = new Random(47);
	
	private Data[] d = {
			new Data(rand.nextInt(10)),
			new Data(rand.nextInt(10)),
			new Data(rand.nextInt(10))
	};
	
	private Worm next;
	
	private char c;
	
	public Worm(int i, char x) {
		System.out.println("Worm constructor: " + i);
		c = x;
		if(--i > 0) {
			next = new Worm(i, (char)(x+1));
		}
	}
	
	public Worm() {
		System.out.println("Default constructor");
	}
	
	public String toString() {
		StringBuilder result = new StringBuilder(":");
		result.append(c);
		result.append("(");
		for(Data data : d) {
			result.append(data);
		}
		result.append(")");
		if(next != null) {
			result.append(next);
		}
		return result.toString();
	}
	
	public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException {
		Worm w = new Worm(6, 'a');
		System.out.println("w = " + w);
		/**
		 * 序列化对象
		 */
		ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("worm.out"));
		out.writeObject("Worm storage\n");
		out.writeObject(w);
		out.close();
		
		/**
		 * 反序列化操作
		 */
		ObjectInputStream in = new ObjectInputStream(new FileInputStream("worm.out"));
		String s = (String)in.readObject();
		Worm w2 = (Worm)in.readObject();
		System.out.println(s + "w2 = " + w2);
		
		ByteArrayOutputStream bout = new ByteArrayOutputStream();
		ObjectOutputStream out2 = new ObjectOutputStream(bout);
		out2.writeObject("Worm storage\n");
		out2.writeObject(w);
		out2.flush();
		
		ObjectInputStream in2 = new ObjectInputStream(new ByteArrayInputStream(bout.toByteArray()));
		s = (String)in2.readObject();
		Worm w3 = (Worm)in2.readObject();
		System.out.println(s + "w3 = " + w3);
	}
}
```

运行结果

```
Worm constructor: 6
Worm constructor: 5
Worm constructor: 4
Worm constructor: 3
Worm constructor: 2
Worm constructor: 1
w = :a(853):b(119):c(802):d(788):e(199):f(881)
Worm storage
w2 = :a(853):b(119):c(802):d(788):e(199):f(881)
Worm storage
w3 = :a(853):b(119):c(802):d(788):e(199):f(881)
```

### 序列化的控制

在特殊情况下，我们不希望对象的某一部分被序列化；或者一个对象被还原以后，某子类对象需要重新创建，从而不必将该子类对象序列化。我们可通过以下方法来实现：

#### 实现Externalizable接口——代替实现Serializable接口——来对序列化过程进行控制。这个Externalizable接口继承了Serializable，同时增添了两个方法：writeExternal()和readExternal()。这两个方法会在序列化和反序列化还的过程中被自动调用。

#### transient关键字

可以用transient关键字逐个关闭序列化。

```java
private transient String password;
```

这里的password域是transient的，所以不会被自动保存到磁盘。另外，自动序列化机制也不会尝试去恢复它。当对象被恢复时，password域就会变成null。

### 使用**持久性**

有下面的问题：
1. 如果我们有两个对象——它们都有指向第三个对象的引用——进行序列化，会发生什么情况？
2. 当我们从它们的序列化状态恢复这两个对时，第三个对象会只出现一次吗？
3. 如果将这两个对象序列化成独立的文件，然后在代码的不同部分对它们进行反序列化还原，又会怎样？

下面的例子说明了上述问题：

```java
class House implements Serializable {}

class Animal implements Serializable {
	private String name;
	private House preferredHouse;
	public Animal(String name, House preferredHouse) {
		this.name = name;
		this.preferredHouse = preferredHouse;
	}
	@Override
	public String toString() {
		return "[" + super.toString() + ", " + preferredHouse + "]";
	}
}

public class MyWord {
	public static void main(String[] args) throws IOException, ClassNotFoundException {
		House house = new House();
		List<Animal> animals = new ArrayList<Animal>();
		animals.add(new Animal("dog", house));
		animals.add(new Animal("cat", house));
		System.out.println("animals:" + animals);
		
		//第一次序列化
		ByteArrayOutputStream buf1 = new ByteArrayOutputStream();
		ObjectOutputStream o1 = new ObjectOutputStream(buf1);
		o1.writeObject(animals);
		o1.writeObject(animals);
		
		//第二次序列化
		ByteArrayOutputStream buf2 = new ByteArrayOutputStream();
		ObjectOutputStream o2 = new ObjectOutputStream(buf2);
		o2.writeObject(animals);
		
		ObjectInputStream in1 = new ObjectInputStream(
				new ByteArrayInputStream(buf1.toByteArray()));
		ObjectInputStream in2 = new ObjectInputStream(
				new ByteArrayInputStream(buf2.toByteArray()));
		List<Animal> animals1 = (List)in1.readObject();
		List<Animal> animals2 = (List)in1.readObject();
		List<Animal> animals3 = (List)in2.readObject();
		
		System.out.println("animals1:" + animals1);
		System.out.println("animals2:" + animals2);
		System.out.println("animals3:" + animals3);
	}

}

```

我们可以通过一个字节数组来使用对象序列化，从而实现任何可序列化对象的**深度复制**。

在这个例子中，Animal对象包含有House类型的字段。在main()方法中，创建了一个Animal列表并将其两次序列化，分别送至不同的流。当其被反序列化还原并被打印时。我们可以看到某次运行后的结果如下：

```
animals:[[Animal@7852e922, House@4e25154f], [Animal@70dea4e, House@4e25154f]]
animals1:[[Animal@7ba4f24f, House@3b9a45b3], [Animal@7699a589, House@3b9a45b3]]
animals2:[[Animal@7ba4f24f, House@3b9a45b3], [Animal@7699a589, House@3b9a45b3]]
animals3:[[Animal@58372a00, House@4dd8dc3], [Animal@6d03e736, House@4dd8dc3]]
```

请注意，在animals1和animals2中出现了相同的地址，包括二者共享的那个指向House对象的引用。另一方面，当恢复animal3时，系统无法知道另一个流内的对象是第一个流内的对象的别名，因此它会产生出完全不同的对象网。

如果对象包含static信息，static数据不会被序列化，如果想序列化static数据，必须自己动手去实现。

## XML

对象序列化的一个重要限制是它只是Java的解决方案：只有Java程序才能反序列化这种对象。一种更具互操作性的解决方案是将数据转换为XML格式，这可以使其被各种各要样的平台和语言使用。使用方法如下:

### 序列化

```java
import nu.xom.Document;
import nu.xom.Element;
import nu.xom.Serializer;

public class Person {
	private String first, last;
	
	public Person(String first, String last) {
		this.first = first;
		this.last = last;
	}
	
	public Element getXML() {
		Element person = new Element("person");
		Element firstName = new Element("first");
		firstName.appendChild(first);
		
		Element lastName = new Element("last");
		lastName.appendChild(last);
		person.appendChild(firstName);
		person.appendChild(lastName);
		return person;
	}
	
	public Person(Element person) {
		this.first = person.getFirstChildElement("first").getValue();
		this.last = person.getFirstChildElement("last").getValue();
	}
	
	public String toString() {
		return this.first + " " + this.last;
	}
	
	public static void format(OutputStream os, Document doc) throws IOException {
		Serializer serializer = new Serializer(os, "ISO-8859-1");
		serializer.setIndent(4);
		serializer.setMaxLength(60);
		serializer.write(doc);
		serializer.flush();
	}
	
	public static void main(String[] args) throws IOException {
		List<Person> people = Arrays.asList(
				new Person("Dr. Bunsen", "Honeydew"),
				new Person("Gonzo", "The Great"),
				new Person("Phillip J.", "Fry"));
		System.out.println(people);
		Element root = new Element("people");
		for(Person p : people) {
			root.appendChild(p.getXML());
		}
		Document doc = new Document(root);
		format(System.out, doc);
		format(new BufferedOutputStream(new FileOutputStream("people.xml")), doc);
		
	}
}
```

运行结果

```xml
[Dr. Bunsen Honeydew, Gonzo The Great, Phillip J. Fry]
<?xml version="1.0" encoding="ISO-8859-1"?>
<people>
    <person>
        <first>Dr. Bunsen</first>
        <last>Honeydew</last>
    </person>
    <person>
        <first>Gonzo</first>
        <last>The Great</last>
    </person>
    <person>
        <first>Phillip J.</first>
        <last>Fry</last>
    </person>
</people>

```

这里使用的开源XOM类库可从 http://www.xom.nu/ 下载。


### 反序列化

```java
public class People extends ArrayList<Person> {
	public People(String fileName) throws Exception {
		Document doc = new Builder().build(new File(fileName));
		Elements elements = doc.getRootElement().getChildElements();
		for(int i=0; i<elements.size(); i++) {
			add(new Person(elements.get(i)));
		}
	}
	
	public static void main(String[] args) throws Exception {
		People p = new People("people.xml");
		System.out.println(p);
	}
}
```

运行结果

```
[Dr. Bunsen Honeydew, Gonzo The Great, Phillip J. Fry]
```

## Preferences

Preferences API与对象序列化相比，前者与对象持久性更密切，因为它可以自动存储和读取信息。不过，它只能用于小的、受限的数据集合——我们只能存储基本类型和字符串，并且每个字符串的存储长度不能超过8K。

Preferences是一个键-值集合，存储在一个节点层次结构中。下面是一个简单的例子：

```java
public class PreferencesDemo {
	public static void main(String[] args) {
		Preferences prefs = Preferences.userNodeForPackage(PreferencesDemo.class);
		prefs.put("Location", "Oz");
		prefs.put("Footwear", "Ruby Slippers");
		prefs.putInt("Companions", 4);
		prefs.putBoolean("Are there witches?", true);
		System.out.println(prefs.get("Location", ""));
		System.out.println(prefs.getInt("Companions", 0));	//第二个参数代表默认值
		System.out.println(prefs.getInt("companions", 0));
	}
}
```

运行结果

```
Oz
4
0
```

这里用的是userNodeForPackage,但我们也可以选择用systemNodeForPackage；虽然可以任意选择，但最好将**user**用于个别用户的偏好，将**system**用于通用的安装配置。

======全文完