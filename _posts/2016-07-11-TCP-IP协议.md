---
date: 2016/7/11 星期一  18:12:01+0800
layout: post
title: TCP/IP协议
thread: 164
categories: TCP/IP
tags:  TCP IP
---

##### 什么是TCP/IP模型？
TCP/IP模型是一系列网络协议的总称，这些协议的目的，就是使计算机之间可以进行信息交换。
所谓"协议"可以理解成机器之间交谈的语言，每一种协议都有自己的目的。TCP/IP模型一共包括几百种协议，对互联网上交换信息的各个方面都做了规定。

##### TCP/IP模型的四层结构
![](/assets/tcpip/tcpip.png)

这些协议可以大致分成四个层次，上一层的协议都以下一层的协议为基础。

从下到上的四层，分别为链路层（Link Layer）、网络层（Internet Layer）、传输层（Transport Layer）、应用层（Application Layer）。
可以这样理解它们的作用：

1. 链路层负责建立电路连接，是整个网络的物理基础，典型的协议包括以太网、ADSL等等；
2. 网络层负责分配地址和传送二进制数据，主要协议是IP协议；
3. 传输层负责传送文本数据，主要协议是TCP协议；
4. 应用层负责传送各种最终形态的数据，是直接与用户打交道的层，典型协议是HTTP、FTP等。

##### TCP头格式
![](/assets/tcpip/MJB-TCP-Header.png)

- Source Port 源端口
- Destination Port 目标端口
- Sequence Number 包的序号，用来解决网络包乱序的问题
- Acknowledgement Number 就是ACK，用于确认收到，用来解决不丢包的问题
- Window 滑动窗口，用于解决流控
- TCP Flag 包的类型，主要是用于操控TCP状态机的。

##### TCP三次握手
- 为什么要时行三次握手
 - 为了保证服务端能接收到客户端的消息，并能做出正确的应答进行前两次握手（第一次和第二次），为了保证客户端能接收到服务端的消息，并能做出正确的应答进行后两次握手（第二次和第三次）
- 建立的过程
 - 第一次握手：客户端发送SYN包（seq=x）到服务器，并进入SYN_SEND状态，等待服务器确认。

 - 第二次握手：服务器收到SYN包，必须确认客户端的SYN（ACK=x+1）,同时也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态。

 - 第三次握手：客户端收到服务器的SYN包，向服务器发送确认包ACK(ACK=y+1)，包ACK发送完毕，双方进入ESTABLISH状态完成三次握手。
 
![](/assets/tcpip/tcp_open_close.jpg)

##### 四次挥手
![](/assets/tcpip/tcpclosesimul.png)
##### TCP的状态机
其实，网络上的传输是没有连接的，包括TCP也是一样的。而TCP所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP的状态变换是非常重要的。
![](/assets/tcpip/tcpfsm.png)

##### 建立连接SYN超时

试想一下，如果server端接到了clien发的SYN后回了SYN-ACK后client掉线了，server端没有收到client回来的ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，server端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻售，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接。

##### SYN Flood攻击
SYN Flood攻击——给服务器发了一个SYN后，就下线了，于是服务器需要默认等63s才会断开连接，这样，攻击者就可以把服务器的syn连接的队列耗尽，让正常的连接请求不能处理。
##### TCP重传机制
TCP要保证所有的数据包都可以到达，所以，必需要有重传机制。
注意，接收端给发送端的Ack确认只会确认最后一个连续的包，比如，发送端发了1,2,3,4,5一共五份数据，接收端收到了1，2，于是回ack 3，然后收到了4（注意此时3没收到），此时的TCP会怎么办？我们要知道，因为正如前面所说的，SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包，不然，发送端就以为之前的都收到了。

###### 超时重传
一种是不回ack，死等3，当发送方发现收不到3的ack超时后，会重传3。一旦接收方收到3后，会ack 回 4——意味着3和4都收到了。
但是，这种方式会有比较严重的问题，那就是因为要死等3，所以会导致4和5即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致4和5的重传。
对此有两种选择：

- 一种是仅重传timeout的包。也就是第3份数据。(节省带宽，但是慢)
- 另一种是重传timeout后所有的数据，也就是第3，4，5这三份数据。(会快一点，但是会浪费带宽)
###### 快速重传
TCP引入了一种叫快速重传的算法，不以时间驱动，而以数据驱动重传。也就是说，如果，包没有连续到达，就ack最后那个可能被丢了的包，如果发送方连续收到3次相同的ack，就重传。快速重传的好处是不用等timeout了再重传。
![](/assets/tcpip/FASTIncast021.png)

###### SACK方法（Selective Acknowledgment）

这种方式需要在TCP头里加一个SACK的东西。ACK还是快速重传的ACK，SACK则是汇报收到的数据碎片。
![](/assets/tcpip/tcp_sack_example-1024x577.jpg)

##### Duplicate SACK – 重复收到数据的问题

Duplicate SACK又称D-SACK，其主要使用了SACK来告诉发送方有哪些数据被重复接收了。
D-SACK使用了SACK的第一个段来做标志

- 如果SACK的第一个段的范围被ACK所覆盖，那么就是D-SACK
- 如果SACK的第一个段的范围被SACK的第二个段覆盖，那么就是D-SACK

示例一：ACK丢包

下面的示例中，丢了两个ACK，所以，发送端重传了第一个数据包（3000-3499），于是接收端发现重复收到，于是回了一个SACK=3000-3500，因为ACK都到了4000意味着收到了4000之前的所有数据，所以这个SACK就是D-SACK——旨在告诉发送端我收到了重复的数据，而且我们的发送端还知道，数据包没有丢，丢的是ACK包。

```
Transmitted  Received    ACK Sent
Segment      Segment     (Including SACK Blocks)
 
3000-3499    3000-3499   3500 (ACK dropped)
3500-3999    3500-3999   4000 (ACK dropped)
3000-3499    3000-3499   4000, SACK=3000-3500
                                    ---------
```

示例二，网络延误

下面的示例中，网络包（1000-1499）被网络给延误了，导致发送方没有收到ACK，而后面到达的三个包触发了“Fast Retransmit算法”，所以重传，但重传时，被延误的包又到了，所以，回了一个SACK=1000-1500，因为ACK已到了3000，所以，这个SACK是D-SACK——标识收到了重复的包。

这个案例下，发送端知道之前因为“Fast Retransmit算法”触发的重传不是因为发出去的包丢了，也不是因为回应的ACK包丢了，而是因为网络延时了。

```
Transmitted    Received    ACK Sent
Segment        Segment     (Including SACK Blocks)
 
500-999        500-999     1000
1000-1499      (delayed)
1500-1999      1500-1999   1000, SACK=1500-2000
2000-2499      2000-2499   1000, SACK=1500-2500
2500-2999      2500-2999   1000, SACK=1500-3000
1000-1499      1000-1499   3000
               1000-1499   3000, SACK=1000-1500
                                      ---------
```

引入了D-SACK，有这么几个好处：

1. 可以让发送方知道，是发出去的包丢了，还是回来的ACK包丢了。
2. 是不是自己的timeout太小了，导致重传。
3. 网络上出现了先发的包后到的情况（又称reordering）
4. 网络上是不是把我的数据包给复制了。

知道这些东西可以很好得帮助TCP了解网络情况，从而可以更好的做网络上的流控。

#####TCP滑动窗口
我们都知道，TCP必需要解决的可靠传输以及包乱序（reordering）的问题，所以，TCP必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。
所以，TCP引入了一些技术和设计来做网络流控，Sliding Window是其中一个技术。 前面我们说过，TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。 为了说明滑动窗口，我们需要先看一下TCP缓冲区的一些数据结构：
![](/assets/tcpip/sliding_window.jpg)
下面我们来看一下发送方的滑动窗口示意图：
![](/assets/tcpip/tcpswwindows.png)
上图中分成了四个部分，分别是：（其中那个黑模型就是滑动窗口）

- #1已收到ack确认的数据。
- #2发还没收到ack的。
- #3在窗口中还没有发出的（接收方还有空间）。
- #4窗口以外的数据（接收方没空间）

下面是个滑动后的示意图（收到36的ack，并发出了46-51的字节）：
![](/assets/tcpip/tcpswslide.png)
下面我们来看一个接受端控制发送端的图示：
![](/assets/tcpip/tcpswflow.png)

上图，我们可以看到一个处理缓慢的Server（接收端）是怎么把Client（发送端）的TCP Sliding Window给降成0的。此时，如果Window变成0了，TCP发送端就不发数据了，你可以想像成“Window Closed”。如果发送端不发数据了，接收方一会儿Window size 可用了，怎么通知发送端呢？

解决这个问题，TCP使用了Zero Window Probe技术，缩写为ZWP，也就是说，发送端在窗口变成0后，会发ZWP的包给接收方，让接收方来ack他的Window尺寸，一般这个值会设置成3次，第次大约30-60秒（不同的实现可能会不一样）。如果3次过后还是0的话，有的TCP实现就会发RST把链接断了

##### 推荐书籍
[![](/content/images/2015/08/s1543906.jpg)](http://book.douban.com/subject/1088054/)