---
date: 2017/2/24 星期五  16:34:14+0800
layout: post
title: 深入理解Java虚拟机(6)-字节码指令简介
thread: 164
categories: 读书笔记
tags:  深入理解Java虚拟机
---

Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字(称为操作码，Opcode)以及跟随其的一的零至多个代表此操作所需参数(称为操作数，Operands)而构成。由于Java虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数的指令都不包含操作数，只有一个操作码。

字节码指令集的优劣势

### 劣势

由于限制了Java虚拟机操作码的长度为一个字节(即0~255)，这意味着指令集的操作码总数不可能超过256条，又由于Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机处理那些超过一个字节数据的时候，不得不在运行时从字节中重建出具体数据的结构，如果要将一个16位长度的无符号整数使用两个无符号字节存储起来(将它们命名为byte1和byte2)，那它们的值应该是这样的:

```java
(byte1<<8) | byte2
```

这种操作在某种程度上会导致解释执行字节码时损失一些性能。

### 优势

放弃操作数长度对齐，就意味着可以省略很多填充和间隔符号；用一个字节来代表操作码，也是为了尽可能获得短小精干的编译代码。

## 1.字节码与数据类型

在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如，iload指令用于从局部变量表中加载int类型的数据到操作数栈中，而float指令加载的则是float类型的数据。这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在Class文件中它们必须拥有各自独立的操作码。

由于Java虚拟机的操作码长度只有一个字节，所以如果每种与数据类型相关的指令都支持Java虚拟机所有运行时数据类型的话，那指令的数量恐怕就会超过一个字节所能表示的数量范围了。因此Java虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它。有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。例如，大部分的指令都没有支持整数类型byte、char和short。编译器会在编译期或运行期将byte和short类型的数据带符号扩展为相应的int类型数据。因此，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的int类型作为运算类型。

## 2.加载和存储指令

加载和存储指令用于将数据在**栈帧中的局部变量表**和**操作数栈**之间来回传输，这类指令包括如下内容：

- 将一个局部变量加载到操作栈：iload、iload_<n>、lload、lload_<n>、fload、fload_<n>、dload、dload_<n>、aload、aload_<n>。
- 将一个数值从操作数栈存储到局部变量表：istore、istore_<n>、lstore、lstore_<n>、fstore、fstore_<n>、dstore、dstore_<n>、astore、astore_<n>。
- 将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_null、iconst_<i>、lconst<<l>、fconst_<f>、dconst_<d>。
- 扩充局部变量表的访问索引的指令：wide。

存储数据的操作数栈和局部变量表主要就是由加载和存储指令进行操作，除此之外，还有少量指令，如访问对象的字段或数组元素的指令也向操作数栈传输数据。

上面所列举的指令助记符中，有一部分是以尖括号结尾的(例如iload_<n>)，这些指令助记符实际上是代表了一组指令(例如iload_<n>、它代表了iload_0、iload_1、iload_2和iload_3这几条指令)。这几组指令都是某个带有一个操作数的通用指令(例如iload)的特殊形式，对于这若干组特殊指令来说，它们省略掉了显式的操作数，不需要进行取操作数的动作，实际上操作数就隐含在指令中。除了这点之外，它们的语义与原生的通用指令完全一致(例如iload_0的语义与操作数为0时的iload指令语义完全一致)。

## 3.运算指令

运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。所有的算术指令如下：

- 加法指令：iadd、ladd、fadd、dadd。
- 减法指令：isub、lsub、fsub、dsub。
- 乘法指令：imul、lmul、fmul、dmul。
- 除法指令：idiv、ldiv、fdiv、ddiv。
- 求余指令：irem、lrem、frem、drem。
- 取反指令：ineg、lneg、fneg、dneg。
- 位移指令：ishl、ishr、iushr、lshl、lshr、lushr。
- 按位或指令：ior、lor。
- 按位与指令：iand、land。
- 按位异或指令：ixor、lxor。
- 局部变量自增指令：iinc。
- 比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp。

Java虚拟机规范规定在处理整型数据时，只有除法指令以及求余指令中当出现除数为零时会导致虚拟机抛出ArithmeticException异常，其余任何整型运算场景都不应该抛出运行时异常。

Java虚拟机规范要求虚拟机实现在进行浮点数运算时，所有的运算结果都必须舍入到适当的精度，非精确的结果必须舍入为可被表示的最接近的精确值，默认舍入模式称为向最接近数舍入模式。

在把浮点数转换为整数时，Java虚拟机使用向零舍入模式。

另外，Java虚拟机在处理浮点数运算时，不会抛出任何运行时异常，当一个操作产生溢出时，将会使用有符号的无穷大来表示，如果某个操作结果没有明确的数学定义的话，将会使用NaN值来表示。所有使用NaN值作为操作数的算术操作，结果都会返回NaN。

## 4.类型转换指令

类型转换指令可以将两种不同的数值类型进行相互转换。

### 1) Java虚拟机直接支持以下数值类型的宽化类型转换：

- int类型到long、float或者double类型。
- long类型到float、double类型。
- float类型到double类型。

### 2) 相对的，处理窄化类型转换时，必须显式地使用转换指令来完成，这些转换指令包括：i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。窄化类型转换可能会导致转换结果产生不同的正负号、不同的数量级的情况，转换过程很可能会导致数值精度的丢失。

#### 将int或long类型窄化转换为整数类型T

转换过程仅仅是简单的保留最低位N个字节的内容。N是类型T的数据类型长度。

#### 将一个浮点值窄化转换为整数类型T(T限于int或long类型之一)

- 如果浮点值是NaN，那转换结果就是int或long类型的0。
- 如果浮点值不是无穷大的话，浮点值使用零舍入模式取整，获得整数值v，如果v在目标类型T(int或long)的表示范围之内，那转换结果就是v。否则将根据v的符号，转换为T所能表示的最大或者最小正数。

#### 将double类型窄化转换为float类型

从double类型到float类型的转换，通过向最接近数舍入模式舍入得到一个可以使用float类型表示的数字。如果转换结果的绝对值大小而无法使用float来表示的话，将返回float类型的正负零。如果转换结果的绝对值太大而无法使用float来表示的话，将返回float类型的正负无穷大，对于double类型的NaN值将按规定转换为float类型的NaN值。

尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是Java虚拟机规范中明确规定类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常。

## 5.对象创建与访问指令

虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令如下：

- 创建类实例的指令：new。
- 创建数组的指令：newarray、anewarray、multianewarray。
- 访问类字段(static字段)和实例字段(非static字段)的指令：getfield、putfield、getstatic、pugstatic。
- 把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload。
- 将一个操作数栈的值存储到元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore。
- 取数组长度的指令：arraylength。
- 检查类实例类型的指令：instanceof、checkcast。

## 6.操作数栈管理指令

如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数栈的指令，包括：

- 将操作数栈的栈顶一个或两个元素出栈：pop、pop2。
- 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2。
- 将栈顶端的两个数值互换：swap。

## 7.控制转移指令

控制转移指令就是在有条件或无条件地修改PC寄存器的值。控制转移指令如下：

- 条件分支：ifeq(==)、iflt(<)、ifle(<=)、ifgt(>)、ifge(>=)、ifnull(==null)、ifnonnull(!=null)、if_icmpeq(int==int)、if_icmpne(int!=int)、if_icmplt(int<int)、if_icmpgt(int>int)、if_icmple(int<=int)、if_icmpge(int>=)、if_acmpeq(ref==ref)、if_acmpne(ref!=ref)。
- 复合条件分支：tableswitch、lookupswitch。
- 无条件分支：goto、goto_w、jsr、jsr_w、ret。

在Java虚拟机中有专门的指令集用来处理int和refence类型的条件分支比较操作，为了可以无须明显标识一个实体值是否null，也有专门的指令用来检测null值。

## 8.方法调用和返回指令

下面列举5条用于方法调用的指令：

- invokevirtual指令用于调用对象实例的方法，根据对象的实际类型进行分派(虚方法分派)，这也是Java语言中最常见的方法分派方式。
- invokeinterface指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。
- invokespecial指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。
- invokestatic指令用于调用类方法(static方法)。
- invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法，前面4条调用指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。

方法的调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括ireturn、lreturn、freturn、dreturn和areturn，另外还有一条return指令声明为void方法、实例初始化方法以及类和接口的类初始化方法使用。

## 9.异常处理指令

在Java虚拟机中显式抛出异常的操作(throw语句)都由athrow指令来实现，除了用throw语句显式抛出异常情况之外，Java虚拟机规范还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。例如，在前面介绍的整数运算中，当除数为零时，虚拟机会在idiv或ldiv指令中抛出ArithmeticException异常。

而在Java虚拟机中，处理异常(catch语句)不是由字节码指令来实现的，而是采用异常表来完成的。

## 10.同步指令

Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程(Monitor)来支持的。

- 方法级同步是隐式的，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法。当方法调用时，调用指令将检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成时释放管程。
- 同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有monitorenter和moniterexit两条指来支持synchronized关键字的语义，正确实现synchronized关键字需要javac编译器与Java虚拟机两者共同协作支持。